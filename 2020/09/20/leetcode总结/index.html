<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="leetcode题目的一些记录，记录方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode总结">
<meta property="og:url" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="siyuan Chen">
<meta property="og:description" content="leetcode题目的一些记录，记录方法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/pchen7592/picgo/raw/master/image-20200730112751015.png">
<meta property="og:image" content="c:/Users/陈思远/AppData/Roaming/Typora/typora-user-images/image-20200812115145367.png">
<meta property="og:image" content="c:/Users/陈思远/AppData/Roaming/Typora/typora-user-images/image-20200812123905412.png">
<meta property="og:image" content="c:/Users/陈思远/AppData/Roaming/Typora/typora-user-images/image-20200812125250593.png">
<meta property="og:image" content="c:/Users/陈思远/AppData/Roaming/Typora/typora-user-images/image-20200812175321802.png">
<meta property="og:image" content="c:/Users/陈思远/AppData/Roaming/Typora/typora-user-images/image-20200812175516556.png">
<meta property="og:image" content="c:/Users/陈思远/AppData/Roaming/Typora/typora-user-images/image-20200812180616301.png">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/question_11.jpg">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0204(20200926-205444).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0205(20200926-212053).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0208(20201007-105959).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode总结/IMG_0209(20201007-161520).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode总结/17_telephone_keypad.png">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0216(20201012-210205).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0223(20201013-075936).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0219(20201012-231955)-1602516046699.PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0220(20201012-232154).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0221(20201012-232832).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode总结/IMG_0226(20201013-121844).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode总结/IMG_0234(20201015-192619).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/image-20201013181746024.png">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/image-20201013183415194.png">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/image-20201013184309190.png">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode总结/IMG_0228(20201013-191205).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0232(20201015-163709).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode总结/IMG_0233(20201015-164448).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/rainwatertrap.png">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0236(20201017-103343).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0237(20201020-173612).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/robot_maze.png">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0238(20201025-205013).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0256(20201103-114503).PNG">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/B0CE192CAF10C22F4E88028E6B19F0C7.png">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/maximal.jpg">
<meta property="og:image" content="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/leetcode%E6%80%BB%E7%BB%93/IMG_0276(20201123-221129).PNG">
<meta property="article:published_time" content="2020-09-20T02:39:42.000Z">
<meta property="article:modified_time" content="2021-02-26T03:18:48.426Z">
<meta property="article:author" content="Peter chen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/pchen7592/picgo/raw/master/image-20200730112751015.png">

<link rel="canonical" href="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-cn'
  };
</script>

  <title>LeetCode总结 | siyuan Chen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">siyuan Chen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://github.com/Peterchen931/Peterchen931.github.io/2020/09/20/leetcode%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peter chen">
      <meta itemprop="description" content="siyuan Chen personal page">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="siyuan Chen">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-20 10:39:42" itemprop="dateCreated datePublished" datetime="2020-09-20T10:39:42+08:00">2020-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-26 11:18:48" itemprop="dateModified" datetime="2021-02-26T11:18:48+08:00">2021-02-26</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">leetcode题目的一些记录，记录方法。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104.二叉树最大深度"></a>104.二叉树最大深度</h2><p><strong>给定一个二叉树，找出其最大深度。</strong></p>
<p><strong>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</strong></p>
<h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><p><strong>方法一</strong></p>
<p>通过遍历二叉树来获取最大深度（先序遍历：根左右）</p>
<p>访问根节点的时，代表从其父节点向下访问一层，故将深度+1。函数在进行左右节点访问后返回，返回即代表回到其父节点，depth-1。使用max记录最大值。</p>
<a id="more"></a>

<p>tips：go语言中没有static类型变量，只好用全局变量保持状态（闭包匿名函数又无法实现递归调用。。。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="keyword">var</span> depth <span class="keyword">int</span>= <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> max <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    depth, max = <span class="number">0</span>, <span class="number">0</span>	<span class="comment">//这一步初始化是因为程序有时会令其初始值为2，如果不报错可省略</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Traverse(root)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Traverse</span><span class="params">(node *TreeNode)</span></span>&#123;</span><br><span class="line">    depth++</span><br><span class="line">    <span class="keyword">if</span> max &lt; depth&#123;</span><br><span class="line">        max = depth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> node.Left!=<span class="literal">nil</span>&#123;</span><br><span class="line">        Traverse(node.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> node.Right!=<span class="literal">nil</span>&#123;</span><br><span class="line">        Traverse(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    depth--</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历和后序遍历为什么不可以？</p>
<p><strong>方法二</strong></p>
<p>通过返回左右节点深度来递归的获取根节点深度。</p>
<p>递归定义：定义节点深度为，其左右节点深度的最大值加1。停止条件：当一个节点为空时其深度为0并返回。通过这两个我们可以写出函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> depth(root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">node: TreeNode</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> node.left != <span class="literal">None</span>:	<span class="comment"># 访问左节点</span></span><br><span class="line">        ld = depth(node.left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ld = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> node.right != <span class="literal">None</span>:	<span class="comment"># 访问右节点</span></span><br><span class="line">        rd = depth(node.right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rd = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> max(ld,rd)+<span class="number">1</span>		<span class="comment"># 访问根节点</span></span><br></pre></td></tr></table></figure>

<p>这其实可以看做是对二叉树的后序遍历。</p>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p>首先，可以思考函数的调用过程，进行函数调用时，被调用的函数会被压入栈顶，当函数返回时，当前函数会被弹出，而当前执行的函数的信息一直保存在栈顶。我们可以采用类似的结构，将递归转变为迭代。</p>
<p>一个函数需要记录的是：调用参数，局部变量，函数执行的状态。（返回值之后会讨论）</p>
<p><strong>将方法一改为迭代</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Traverse</span><span class="params">(node *TreeNode)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 第一件事：访问根节点</span></span><br><span class="line">    depth++</span><br><span class="line">    <span class="keyword">if</span> max &lt; depth&#123;</span><br><span class="line">        max = depth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二件事：访问左节点</span></span><br><span class="line">    <span class="keyword">if</span> node.Left!=<span class="literal">nil</span>&#123;</span><br><span class="line">        Traverse(node.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第三件事：访问右节点</span></span><br><span class="line">    <span class="keyword">if</span> node.Right!=<span class="literal">nil</span>&#123;</span><br><span class="line">        Traverse(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第四件事：返回父节点</span></span><br><span class="line">    depth--</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次我们按照函数调用的思路来改造该函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stackframe</span>:</span>   <span class="comment"># 记录栈帧</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node, status</span>):</span></span><br><span class="line">        self.node = node    	<span class="comment"># 记录当前节点</span></span><br><span class="line">        self.status = status	<span class="comment"># 记录当前做第几件事</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        depth = <span class="number">0</span>   <span class="comment"># 当前节点深度</span></span><br><span class="line">        maxd = <span class="number">0</span>    <span class="comment"># 最大深度</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stack = [stackframe(root, <span class="number">1</span>)]  <span class="comment"># 将root压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(len(stack) != <span class="number">0</span>):</span><br><span class="line">            top = stack[len(stack)<span class="number">-1</span>]  <span class="comment"># 从栈顶获取参数</span></span><br><span class="line">            <span class="keyword">if</span> top.status == <span class="number">1</span>:        <span class="comment"># 执行第一条语句</span></span><br><span class="line">                depth +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> maxd &lt; depth:</span><br><span class="line">                    maxd = depth</span><br><span class="line">                top.status += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top.status == <span class="number">2</span>:        <span class="comment"># 执行第二条语句</span></span><br><span class="line">            	<span class="comment"># if node.Left!=nil&#123;</span></span><br><span class="line">        		<span class="comment"># 	Traverse(node.Left)</span></span><br><span class="line">    			<span class="comment"># &#125;</span></span><br><span class="line">                <span class="comment"># 与下面逻辑一致</span></span><br><span class="line">                <span class="keyword">if</span> top.node.left != <span class="literal">None</span>:</span><br><span class="line">                    top.status += <span class="number">1</span></span><br><span class="line">                    stack.append(stackframe(top.node.left, <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    top.status += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top.status == <span class="number">3</span>:        <span class="comment"># 执行第三条语句</span></span><br><span class="line">                <span class="keyword">if</span> top.node.right != <span class="literal">None</span>:</span><br><span class="line">                    top.status += <span class="number">1</span></span><br><span class="line">                    stack.append(stackframe(top.node.right, <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    top.status += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top.status == <span class="number">4</span>:        <span class="comment"># 执行第四条语句</span></span><br><span class="line">                depth -= <span class="number">1</span></span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> maxd</span><br></pre></td></tr></table></figure>

<p>node字段记录当前节点的指针，用来访问节点</p>
<p>status字段用于记录节点的运行状态。类比函数调用，假设A调用B，当B返回后A继续执行，这个继续执行的位置就由status记录。</p>
<p>首先把root节点压入栈，之后进入循环体，在循环体中每次都访问栈顶（类比当前执行的函数），根据status判断执行哪一步。</p>
<p>当status等于2和3时，在递归方式中是函数调用，这里我们就要进行手动的push stack，将数据压入栈中，这里压入的数据有参数node，函数状态status。之后重新开始迭代，类比进入了被调用的函数</p>
<p>status等于4时，需要将执行返回任务，深度-1并pop stack。pop 代表了函数的返回</p>
<p><strong>总结</strong>：</p>
<p>当进行函数调用时，转变为手工push stack，记录传入参数，状态。当函数返回时，pop stack。</p>
<p>这里的程序被我划分为了4个动作，具体动作划分的逻辑，我认为就是按照函数调用划分开：</p>
<p><img src="https://gitee.com/pchen7592/picgo/raw/master/image-20200730112751015.png" alt="image-20200730112751015"></p>
<p><strong>将方法2转为迭代</strong></p>
<p>方法2的函数中涉及到了返回值，这就涉及了返回值的处理。</p>
<p>首先有一个认知，一个函数栈中两个相邻的元素，在下面的是调用者，上面的是被调用者。</p>
<p>给栈中创建一个放置返回值的字段，然后将返回值放入栈顶下一个元素放置返回值的位置，然后由调用者决定这个值怎么用。</p>
<p>不过这个整体比较复杂，，，然后一开始是用python写的，然后发现它没指针。。。。所以就偷懒没弄了</p>
<p><strong>进一步思考</strong></p>
<p>后面又想了想，我发现这两种依据修改递归的方法无非就是记录了状态，那我何必需要将任务依据函数调用进行划分呢？只需要记录其是否访问过左，右节点就行了。</p>
<p>首先写了一个迭代的后序遍历函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node, go_left, go_right</span>):</span></span><br><span class="line">        self.node = node</span><br><span class="line">        self.go_left = go_left</span><br><span class="line">        self.go_right = go_right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LRD</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(node(root, <span class="literal">False</span>, <span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">while</span>(len(stack) != <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 获取栈顶</span></span><br><span class="line">            cur_node = stack[len(stack)<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># 访问左子树</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.go_left == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> cur_node.node.left != <span class="literal">None</span>:</span><br><span class="line">                    cur_node.go_left = <span class="literal">True</span></span><br><span class="line">                    stack.append(node(cur_node.node.left, <span class="literal">False</span>, <span class="literal">False</span>))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_node.go_left = <span class="literal">True</span></span><br><span class="line">			<span class="comment"># 访问右子树</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.go_right == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> cur_node.node.right != <span class="literal">None</span>:</span><br><span class="line">                    cur_node.go_right = <span class="literal">True</span></span><br><span class="line">                    stack.append(node(cur_node.node.right, <span class="literal">False</span>, <span class="literal">False</span>))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_node.go_right = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 访问</span></span><br><span class="line">            print(cur_node.node.val)</span><br><span class="line">            stack.pop()</span><br></pre></td></tr></table></figure>

<p>然后需要将后序遍历改成返回最大深度的函数，难点还是返回值的处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.node = node</span><br><span class="line">        self.go_left = <span class="literal">False</span></span><br><span class="line">        self.go_right = <span class="literal">False</span></span><br><span class="line">        self.rdepth = <span class="number">0</span></span><br><span class="line">        self.ldepth = <span class="number">0</span></span><br><span class="line">        self.retval = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stack.append(node(root))</span><br><span class="line">        <span class="keyword">while</span>(len(stack) != <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 获取栈顶</span></span><br><span class="line">            cur_node = stack[len(stack)<span class="number">-1</span>]</span><br><span class="line">			<span class="comment"># 处理返回值</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.go_right == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> cur_node.go_left == <span class="literal">True</span>:</span><br><span class="line">                    cur_node.ldepth = cur_node.retval</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_node.rdepth = cur_node.retval</span><br><span class="line">			<span class="comment"># 访问左子树</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.go_left == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> cur_node.node.left != <span class="literal">None</span>:</span><br><span class="line">                    cur_node.go_left = <span class="literal">True</span></span><br><span class="line">                    stack.append(node(cur_node.node.left))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_node.go_left = <span class="literal">True</span></span><br><span class="line">			<span class="comment"># 访问右子树</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.go_right == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> cur_node.node.right != <span class="literal">None</span>:</span><br><span class="line">                    cur_node.go_right = <span class="literal">True</span></span><br><span class="line">                    stack.append(node(cur_node.node.right))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_node.go_right = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 返回退栈，如果stack长度等于1，代表只剩下根节点了，直接return</span></span><br><span class="line">            <span class="keyword">if</span> len(stack) &gt; <span class="number">1</span>:</span><br><span class="line">                stack[len(stack)<span class="number">-2</span>].retval = \</span><br><span class="line">                        max(cur_node.ldepth, cur_node.rdepth) + <span class="number">1</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> max(cur_node.ldepth, cur_node.rdepth) + <span class="number">1</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>在这个特定问题中返回值的处理，还是比较容易解决的，只要判断该节点是否访问过左右节点就行，如果访问过左，没访问过右，则该返回值赋值给左，如果访问过左右，则赋值给右，其与情况不会出现有意义的返回值。这种方法虽然可行，但是总觉得不是很有扩展性。</p>
<p>最后，当栈大小再次回到1时，即仅剩根节点，这是这时只需要将深度返回即可。</p>
<p><strong>总结</strong></p>
<p>通过这个题目，我也顺带复习了下函数的运行规则与调用规则，并且复习了如何将递归函数转化为迭代函数的方法。</p>
<h2 id="面试题-10-01-合并排序的数组"><a href="#面试题-10-01-合并排序的数组" class="headerlink" title="面试题 10.01. 合并排序的数组"></a>面试题 10.01. 合并排序的数组</h2><p><strong>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</strong></p>
<p><strong>初始化 A 和 B 的元素数量分别为 m 和 n。</strong></p>
<p>合并排序好的数组在有足够空间的情况下，所需的时间复杂度是O(m+n)，这道题的关键是如何使用最少的空间复杂度来解决该问题。</p>
<p>所以思考一个不需要额外空间的合并方法，常规的从小到大是不可行的，因为从数组中间插入的开销是O(n)级别的。</p>
<p>考虑从合并后最后位置插入，由于A有足够大的空间，合并后A仍能容纳，不需要额外空间，同时从末尾插入不需要对数组元素进行移位，搞定！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=m+n<span class="number">-1</span>;	<span class="comment">// 合并后最后一个元素位置</span></span><br><span class="line">        m--;	<span class="comment">// 这里省2个变量的内存，不过感觉这样修改不好让人看懂</span></span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;=<span class="number">0</span> &amp;&amp; n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[m] &gt; B[n])&#123;</span><br><span class="line">                A[k--] = A[m--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                A[k--] = B[n--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)&#123;	</span><br><span class="line">            A[k--] = B[n--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里如果m或者n大于0代表一个数组归并完成一个数组有剩余，如果A有剩余则就会放入其原来的位置，所以可以省略</span></span><br><span class="line">        <span class="comment">//while(m&gt;=0)&#123;		</span></span><br><span class="line">        <span class="comment">//    A[k--] = A[m--];</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836. 矩形重叠"></a>836. 矩形重叠</h2><p><strong>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。给出两个矩形，判断它们是否重叠并返回结果。</strong></p>
<p><strong>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。</strong><br><strong>矩形中的所有坐标都处于 -10^9 和 10^9 之间。</strong><br><strong>x 轴默认指向右，y 轴默认指向上。</strong><br><strong>你可以仅考虑矩形是正放的情况。</strong></p>
<p>两个矩形的位置会有很多不同的情况，如果将其一一列举再进行判断，就会十分复杂。</p>
<p>一个十分简单的判断方法就是将两个矩形分别投影至x，y轴上，再判断每一个轴上的投影是否有重叠，如果x，y轴投影均有重叠，则矩形有重叠，否则无重叠。(这道题考验转化能力)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLineOverlap</span><span class="params">(<span class="keyword">int</span> amin, <span class="keyword">int</span> amax, <span class="keyword">int</span> bmin, <span class="keyword">int</span> bmax)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amin &lt; bmin)&#123;</span><br><span class="line">        <span class="keyword">if</span>(amax &lt;= bmin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(amin &gt; bmin)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bmax &lt;= amin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isLineOverlap(rec1[<span class="number">0</span>], rec1[<span class="number">2</span>], rec2[<span class="number">0</span>], rec2[<span class="number">2</span>]) &amp;&amp; </span><br><span class="line">           isLineOverlap(rec1[<span class="number">1</span>], rec1[<span class="number">3</span>], rec2[<span class="number">1</span>], rec2[<span class="number">3</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h2><p><strong>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</strong></p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>这个问题如果使用暴力解，搜索每一种可能性，则需要搜索5x5,4x4,3x3,2x2,1x1大小的所有正方形，计算复杂度十分大，不可取。</p>
<p>由于这个问题明显不能划分为<strong>独立的</strong>子问题，所以不能用分治。自然思考到了动态规划。</p>
<p>动态规划的关键是思考子问题的的划分方法，将大问题划分为子问题。</p>
<p><strong>经历了如下历程</strong></p>
<ol>
<li>dp[i]代表左上ixi正方形区域中最大的正方形面积。但是题目的区域并不一定是正方形，所以需要变一下。</li>
<li>dp[i,j]代表的是从左上，到第i行，第j列的最大正方形面积。这种构建子问题的方法问题在于构建dp[i,j] = f(dp[i,j-1])这样的递推关系式时，有些困难。</li>
<li>dp[i,j]代表以(i,j)为右下角坐标的最大的正方形，最后只需要遍历整个dp[i,j]，就能找到最大的正方形。</li>
</ol>
<p>那么递推关系式又如何寻找呢，由于定义的问题是<strong>dp[i,j]代表以(i,j)为右下角坐标的最大的正方形</strong>，所以其大小肯定与左上方区域有关，dp算法一般考虑其<strong>临近</strong>的几个值，这里我先尝试dp[i-1,j], dp[i,j-1], dp[i-1,j-1]这3个</p>
<p><img src="C:\Users\陈思远\AppData\Roaming\Typora\typora-user-images\image-20200812115145367.png" alt="image-20200812115145367"></p>
<p>若matrix[i,j] == 0, 则dp[i,j] = 0</p>
<p>若matrix[i,j] = =1, 则去寻找dp[i,j]与dp[i-1,j], dp[i,j-1], dp[i-1,j-1]的关系。</p>
<p><img src="C:\Users\陈思远\AppData\Roaming\Typora\typora-user-images\image-20200812123905412.png" alt="image-20200812123905412"></p>
<p>于是我们得到递推关系式：</p>
<p>​    dp[i,j] = 0     if matrix[i,j] == 0</p>
<p>​    dp[i,j]=min{dp[i-1,j], dp[i,j-1], dp[i-1,j-1]}     if matrix[i,j] == 1</p>
<p>这个递推关系需要确定左上角3个值。</p>
<p>接下来寻找初值条件，显而易见的，左上角部分值只能为0,1。有了初值，就可以进行迭代求解了：</p>
<p><img src="C:\Users\陈思远\AppData\Roaming\Typora\typora-user-images\image-20200812125250593.png" alt="image-20200812125250593"></p>
<p>迭代的方向是从左上到右下，最后找到最大的dp[i,j]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">triMin</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        num1 &lt; num2 ? min = num1 : min = num2;</span><br><span class="line">        min &lt; num3 ?  min = min : min = num3;</span><br><span class="line">        <span class="keyword">return</span> min; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取matrix大小</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">maxM</span><span class="params">(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; maxM.size() &lt;&lt; maxM[0].size();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定初值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> iterRow = <span class="number">0</span>; iterRow &lt; matrix.size(); iterRow++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[iterRow][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                maxM[iterRow][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                maxM[iterRow][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> iterCol = <span class="number">1</span>; iterCol &lt; matrix[<span class="number">0</span>].size(); iterCol++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][iterCol] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                maxM[<span class="number">0</span>][iterCol] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                maxM[<span class="number">0</span>][iterCol] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左上往右下赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; min(row,col); i++)&#123;	</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    maxM[i][j] = triMin(maxM[i<span class="number">-1</span>][j], maxM[i][j<span class="number">-1</span>], maxM[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    maxM[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; row; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[j][i] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    maxM[j][i] = triMin(maxM[j<span class="number">-1</span>][i], maxM[j][i<span class="number">-1</span>], maxM[j<span class="number">-1</span>][i<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    maxM[j][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // 输出matrix</span></span><br><span class="line">        <span class="comment">// for(int iterRow = 0; iterRow &lt; row; iterRow++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int iterCol = 0; iterCol &lt; col; iterCol++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; matrix[iterRow][iterCol] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;\n\n&quot;;</span></span><br><span class="line">        <span class="comment">// // 输出maxM</span></span><br><span class="line">        <span class="comment">// for(int iterRow = 0; iterRow &lt; row; iterRow++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int iterCol = 0; iterCol &lt; col; iterCol++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; maxM[iterRow][iterCol] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到最大面积</span></span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> iterRow = <span class="number">0</span>; iterRow &lt; row; iterRow++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> iterCol = <span class="number">0</span>; iterCol &lt; col; iterCol++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (maxM[iterRow][iterCol] &gt; maxlen)&#123;</span><br><span class="line">                    maxlen = maxM[iterRow][iterCol];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen*maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事实上还有优化方法，就是可以在对dp进行赋值时就进行最大值统计，这样可以省去最后一个循环。</p>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p>这显然是一个动态规划算法题，关键是如何构造递归关系式。</p>
<p><strong>一开始我的想法是</strong></p>
<p>记录以i为结尾的最长的回文字符串。dp[i]的值记录最长串的起始位置。范围[dp[i]~i]</p>
<p>dp[i] = dp[i-1]    if s[i] == s[dp[i]-1]</p>
<p>但是当s[i] ≠ s[dp[i]-1] 事情就复杂了，我们无法从记录的信息dp[i-1]中获取我们需要的信息，所以这个方法不可行。</p>
<p><strong>答案方法:</strong></p>
<p><strong>首先是递归关系式</strong></p>
<p>记dp[i,j]为s[i]~s[j]是否为回文字符串。显然需要i&lt;=j。</p>
<p>关键的观察，如果一个串是回文字符串，那么其左右个减少一个元素的字串也是回文字符串</p>
<p>dp[i,j] = true    if dp[i+1,j-1] == true且 s[i] == s[j]</p>
<p>递归关系式找到了。</p>
<p><strong>接下来寻找初值</strong></p>
<p>dp[i,i] = true，</p>
<p>dp[i, i+1] = true     if s[i] == s[i+1]</p>
<p>计算方式可以画成下图</p>
<p><img src="C:\Users\陈思远\AppData\Roaming\Typora\typora-user-images\image-20200812175321802.png" alt="image-20200812175321802"></p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> dp[s.size()][s.size()];</span><br><span class="line">        <span class="keyword">int</span> i,j = <span class="number">0</span>;    <span class="comment">// 迭代变量，i代表行号，i+j代表列号</span></span><br><span class="line">        <span class="comment">// 设定初值</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            s[i] == s[i+<span class="number">1</span>] ? dp[i][i+<span class="number">1</span>] = <span class="literal">true</span> : dp[i][i+<span class="number">1</span>] = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 根据迭代关系式计算</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s.size()-j; i++)&#123;</span><br><span class="line">                (dp[i+<span class="number">1</span>][i+j<span class="number">-1</span>] &amp;&amp; s[i] == s[i+j]) ? dp[i][i+j] = <span class="literal">true</span> : dp[i][i+j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// // 打印dp表</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; s.size(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j &lt; s.size(); j++)&#123;</span></span><br><span class="line">        <span class="comment">//         i &gt; j ? cout &lt;&lt; 0 : cout &lt;&lt; dp[i][j];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到最大的回文串</span></span><br><span class="line">        <span class="keyword">for</span>(j = s.size()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s.size()-j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][i+j] == <span class="literal">true</span>)</span><br><span class="line">                    <span class="keyword">return</span> s.substr(i,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;oops&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>进一步的优化</strong></p>
<p>再次回顾计算方式图</p>
<p><img src="C:\Users\陈思远\AppData\Roaming\Typora\typora-user-images\image-20200812175516556.png" alt="image-20200812175516556"></p>
<p>我们只需要最大项，而之前的方法会记录所有的值。所以思考能否不用dp数组存储，直接储存最大值。</p>
<p>之所以需要存储dp结果的原因是，我们需要获取依赖值来进行迭代关系式运算，所以，考虑将计算方向改为迭代依赖方向。</p>
<p><img src="C:\Users\陈思远\AppData\Roaming\Typora\typora-user-images\image-20200812180616301.png" alt="image-20200812180616301"></p>
<p>这样就不需要对结果进行存储了，并且可以直接在计算过程中记录最大值。</p>
<p>代码如下：</p>
<p>(待完成)</p>
<h2 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a>1248. 统计「优美子数组」</h2><p><strong>给你一个整数数组 nums 和一个整数 k。</strong></p>
<p><strong>如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</strong></p>
<p><strong>请返回这个数组中「优美子数组」的数目。</strong></p>
<p>这道题我一开始想用动态规划来做，但是想到了一个也很简单的方法，就先解决了。</p>
<p>首先，发现一个事实，在优美子数组的左右如果有偶数，则加上这些偶数仍是优美子数组，直到加上了一个奇数，则失效。</p>
<p>其次，优美子数组只与奇数出现有关。所以只需要统计奇数信息即可。</p>
<p>再者在一个优美子数组且左右两边都是奇数的子数组左右各加m，n个偶数，可以得到满足要求的子数组为(m+1)*(n+1)个。</p>
<p>所以可以通过找到不同的左右两边都是奇数的优美子数组进行<strong>扩张</strong>，计算出优美子数组个数。</p>
<p>通过该方法可以以O(n)的时间复杂度解决问题。</p>
<p>首先遍历一次数组，记录奇数位置location[]</p>
<p>再遍历一次数组，记录奇数位置之间的间隔location_interval[]</p>
<p>通过间隔计算即：location_interval[i] * location_interval[i+k]</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; odd_location;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; location_interval;</span><br><span class="line">        <span class="comment">// int location[nums.size()];</span></span><br><span class="line">        <span class="comment">// 记录奇数出现的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                odd_location.push_back(i);  <span class="comment">//location记录下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录各个位置之间的间隔</span></span><br><span class="line">        <span class="keyword">if</span>(odd_location.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            location_interval.push_back(odd_location[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; odd_location.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">                location_interval.push_back(odd_location[i+<span class="number">1</span>]-odd_location[i]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> 			location_interval.push_back(nums.size()<span class="number">-1</span> - </span><br><span class="line">                                        odd_location[odd_location.size()<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过间隔计算优美子数组个数</span></span><br><span class="line">        <span class="keyword">int</span> numOfSubarr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i+k &lt; location_interval.size(); i++)&#123;</span><br><span class="line">            numOfSubarr += (location_interval[i]+<span class="number">1</span>) * (location_interval[i+k]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// // 输出odd_location</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; odd_location.size(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; odd_location[i];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// // 输出location_interval</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; location_interval.size(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; location_interval[i];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> numOfSubarr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="466-统计重复个数"><a href="#466-统计重复个数" class="headerlink" title="466. 统计重复个数"></a>466. 统计重复个数</h2><p><strong>由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[“abc”,3]=“abcabcabc”。</strong></p>
<p><strong>如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，”abc” 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。</strong></p>
<p><strong>现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。</strong></p>
<p><strong>请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。</strong></p>
<p> <strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">s1 &#x3D;&quot;acb&quot;,n1 &#x3D; 4</span><br><span class="line">s2 &#x3D;&quot;ab&quot;,n2 &#x3D; 2</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<p>这道题做不出来，使用的是组合数学方面的知识，通过构造循环节来迅速跳过中间重复段，循环节的存在性可以使用鸽笼原理证明。</p>
<p>一开始我的想法是：去计算能够使用几个s1构造s2，或者是一个s1能构造几个s2，但是这样的方法会漏掉一些可行的部分，下例可说明：”bbb” 4 “bb” 2。</p>
<p>解答可以看官方解答视频。</p>
<p>这里说几个痛点</p>
<ol>
<li>如何去寻找循环节</li>
<li>寻找循环节方法的正确性</li>
<li>循环节的存在性</li>
<li>到底是什么在循环</li>
</ol>
<h2 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="11. 盛水最多的容器"></a>11. 盛水最多的容器</h2><p><strong>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</strong></p>
<p><strong>说明：你不能倾斜容器，且 n 的值至少为 2。<img src="leetcode%E6%80%BB%E7%BB%93/question_11.jpg" alt="img"></strong></p>
<p><strong>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</strong></p>
<p><strong>示例：</strong></p>
<p><strong>输入：[1,8,6,2,5,4,8,3,7]</strong><br><strong>输出：49</strong></p>
<p>暴力算法，双重循环便利所有可能，复杂度O(n^2^)。故需要寻找一种低于此复杂度的解</p>
<p>解：在解决本题目时，首先就去考虑了动态规划。但是其状态不是很好定义，并且时间复杂度也难以做到O(n)</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0204(20200926-205444).PNG" alt="IMG_0204(20200926-205444)"></p>
<p>只能换一种思路</p>
<p>由于该问题有n*(n-1)种组合方法，如果要做到O(n)复杂度，那么必须要在单次的搜索排除掉O(n)个可能的组合。</p>
<p>可以利用双指正法来解决。双指针法的推导可以看官方解答 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/">盛水最多的容器</a>，这里仅分析其正确性以及高效的原因。</p>
<p>为什么移动数值小的一边？</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0205(20200926-212053).PNG" alt="IMG_0205(20200926-212053)"></p>
<p>能够达到O(n)复杂度的原因也是这个，即在每一次指针移动的过程中，都排除掉了O(n)个组合。</p>
<p>获知解题方法后，编写程序就很简单了，毕竟这是一个O(n)复杂度的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = height.size();</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = num<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_cap = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)&#123;	</span><br><span class="line">            max_cap = max(max_cap, min(height[begin], height[end]) * (end - begin)); <span class="comment">//记录当前容量</span></span><br><span class="line">            <span class="keyword">if</span>(height[begin] &lt; height[end])&#123;	<span class="comment">// 移动较小高度的指针</span></span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_cap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p><strong>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</strong></p>
<p><strong>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<p>利用hash_table 进行搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确定一个数a</span></span><br><span class="line"><span class="comment">// 利用hash_table寻找数b，使得满足a+b=target</span></span><br><span class="line"><span class="comment">// 具体实施即遍历整个数组，对每一个元素寻找b，找到即返回</span></span><br><span class="line"><span class="comment">// 此方法同时也避免了hash_table重复搜索的问题，即target=4，只有一个2却使用两次返回2+2=4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator res = umap.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(res == umap.end())&#123;</span><br><span class="line">                umap.emplace(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;res-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; nums[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><ol>
<li><p>排序+双指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.排序</span><br><span class="line">2.从小到大遍历，先定一个数a</span><br><span class="line">3.寻找两数字和b+c&#x3D;-a</span><br><span class="line">4.利用双指针寻找两数字和（由于数组是排好序的，所以可以使用双指针）</span><br><span class="line">5.空间复杂度，O(1)因为不需要构建额外的数组</span><br><span class="line">6.时间复杂度，O(n^2)，双循环</span><br><span class="line">7.去重（巧妙的方法O(1)？）</span><br></pre></td></tr></table></figure>

<p>双指针正确性证明：</p>
<p>​    设有[a, b, n1, n2, n3, n4, c]</p>
<p>​    当a+b+c &gt; 0 时，可以排除[n1，c], [n2，c], [n3，c], [n4, c] 所有数字的组合（这个和盛水容器很像）</p>
<p>​    当a+b+c &gt; 0 时，可以排除[b，n4], [b，n3], [b，n2], [b，n1]中所有数字的组合</p>
<p>所以，当a+b+c &gt; 0，其实已经隐性排除了[n1，c], [n2，c], [n3，c], [n4, c] 这个区间，即探测了c的所有组合，所以由指针左移。</p>
<p>当a+b+c &lt; 0 同理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="comment">// 从小到大遍历，先定一个数a</span></span><br><span class="line">        <span class="comment">// 寻找两数字和b+c=-a</span></span><br><span class="line">        <span class="comment">// 利用双指针寻找两数字和（由于数组是排好序的，所以可以使用双指针）</span></span><br><span class="line">        <span class="comment">// 空间复杂度，O(1)因为不需要构建额外的数组</span></span><br><span class="line">        <span class="comment">// 时间复杂度，O(n^2)，双循环</span></span><br><span class="line">        <span class="comment">// 去重（巧妙的方法O(1)？）</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rec_vec;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.size(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;   <span class="comment">// 先定一个数a</span></span><br><span class="line">            <span class="keyword">if</span>(  i&gt;<span class="number">0</span>?!(nums[i]==nums[i<span class="number">-1</span>]):<span class="literal">true</span>  )&#123; <span class="comment">// 这里是用于去重，当当前数字等于前一个数，代表该数字的组合已经在更大的空间寻找过了，直接跳过</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>, k = nums.size()<span class="number">-1</span>; j&lt;k ;)&#123; <span class="comment">// 双指针遍历</span></span><br><span class="line">                    <span class="keyword">int</span> three_sum = nums[j]+ nums[k] + nums[i]; </span><br><span class="line">                    <span class="keyword">if</span>(three_sum == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp&#123;nums[i], nums[j], nums[k]&#125;;</span><br><span class="line">                        <span class="keyword">if</span>(rec_vec.empty()? <span class="literal">true</span> : temp != rec_vec.back())&#123; <span class="comment">// 这也是用作去重，由于是在有序数组中搜索答案，所以重复的结果只可能相邻出现</span></span><br><span class="line">                            rec_vec.push_back(temp);</span><br><span class="line">                            j++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(three_sum &gt; <span class="number">0</span>)  <span class="comment">// 三数之和大于0则证明数字大了，需要减小</span></span><br><span class="line">                            k--;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用两数字和</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.不排序，直接利用两数字和的方法</span><br><span class="line">2.从左到右遍历，先定一个数a</span><br><span class="line">3.利用两数之和的方法构造hash_table进行寻找</span><br><span class="line">4.时间复杂度O(n^2)，遍历为O(n)，寻找两数之和为O(n)</span><br><span class="line">5.如果建立数值哈希，最坏空间复杂度O(2^n)，利用较好的哈希算法可以减少，不过可能会减慢查询</span><br><span class="line">6.去重，vec-&gt;set-&gt;vec（这个时间复杂度为O(n),不会影响算法复杂度）</span><br></pre></td></tr></table></figure>

<p> 这里没有进行实现，不过注意</p>
<ol>
<li>两数之和那道题返回的是一个值，这里需要改成返回一组值</li>
<li>不能先定两个数，在利用hash_table寻找第三个数，因为如果是一开始建表，那么会有重复的搜索空间，如：<code>[1,2,-2,-1]</code>，会找到<code>[[-2,1,1]]</code>，而这个答案重复使用了1。(如果在哈希表value定义为一个数字出现的次数可能可以解决，但那样太复杂了。)</li>
</ol>
</li>
</ol>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p><strong>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</strong></p>
<p><strong>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</strong></p>
<p><strong>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>



<p>本题比较简单，只需要注意理清判断条件即可。</p>
<p>这里使用的是原地相加的方法，答案储存在l1中，空间复杂度为O(1)。这种方法困难的地方是当l1不够长，达到nullptr，需要一个before指针储存其前一个位置以进行append。</p>
<p>其实还有一个方法，就是先判断那个列表长，如果l2长，则进行l1,l2交换，保证l1是长的，不过这样要花费更高的时间复杂度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, temp_carry = <span class="number">0</span>;  <span class="comment">// temp_carry是因为后面的语句需要暂时缓存</span></span><br><span class="line">        <span class="function">ListNode <span class="title">l1_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        l1_head.next = l1;</span><br><span class="line">        ListNode* l1_fore = &amp;l1_head;</span><br><span class="line">        <span class="keyword">while</span>(  !(l1==<span class="literal">nullptr</span> &amp;&amp; l2==<span class="literal">nullptr</span> &amp;&amp; carry==<span class="number">0</span>)  )&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;         <span class="comment">// 链表同时有值，正常相加</span></span><br><span class="line">                <span class="comment">// 这两句一个会覆盖l1_val,另一个会覆盖carry，</span></span><br><span class="line">                <span class="comment">// 所以必须将一个值缓存起来，这里使用了temp_carry缓存carry</span></span><br><span class="line">                l1-&gt;val+l2-&gt;val+carry &lt; <span class="number">10</span> ? temp_carry=<span class="number">0</span> : temp_carry=<span class="number">1</span>;   </span><br><span class="line">                l1-&gt;val = (l1-&gt;val+l2-&gt;val+carry) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">                carry = temp_carry;</span><br><span class="line">                l1 = l1-&gt;next;·	</span><br><span class="line">                l1_fore = l1_fore-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2==<span class="literal">nullptr</span>)&#123;    <span class="comment">// l2到达末尾</span></span><br><span class="line">                l1-&gt;val+carry &lt; <span class="number">10</span> ? temp_carry=<span class="number">0</span> : temp_carry=<span class="number">1</span>;</span><br><span class="line">                l1-&gt;val = (l1-&gt;val+carry) % <span class="number">10</span>;</span><br><span class="line">                carry = temp_carry;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">                l1_fore = l1_fore-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l1==<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;    <span class="comment">// l1到达末尾</span></span><br><span class="line">                l2-&gt;val+carry &lt; <span class="number">10</span> ? temp_carry=<span class="number">0</span> : temp_carry=<span class="number">1</span>;</span><br><span class="line">                l1 = <span class="keyword">new</span> ListNode( (l2-&gt;val+carry) % <span class="number">10</span> );</span><br><span class="line">                carry = temp_carry;</span><br><span class="line">                l1_fore-&gt;next = l1;</span><br><span class="line"></span><br><span class="line">                l1_fore = l1_fore-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;   <span class="comment">//(l1==nullptr &amp;&amp; l2==nullptr &amp;&amp; carry=1)</span></span><br><span class="line">                l1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);   <span class="comment">// 能够达到这里的情况只有 </span></span><br><span class="line">                						<span class="comment">// (l1==nullptr &amp;&amp; l2==nullptr &amp;&amp; carry=1)</span></span><br><span class="line">                l1_fore-&gt;next = l1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p>
<p><strong>进阶</strong>：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class="line">输出：0.00000</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class="line">输出：1.00000</span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [2], nums2 &#x3D; []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></table></figure>

<p>这道题的关键就是如何去找到划分子任务的方法，过程可以看官方解答<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">寻找两个正序数组的中位数</a></p>
<p>这里主要说一下解答代码中的一些巧妙的处理方法</p>
<p>首先是将奇数与偶数个数字进行了划分，将问题分成了两类。</p>
<p>再者是利用index代表vec被删除的部分，因为vector实施删除的复杂度是比较高的。</p>
<p>接着是对一些边界条件的处理，引用解答原文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有以下三种情况需要特殊处理：</span><br><span class="line"></span><br><span class="line">    如果 A[k&#x2F;2-1] 或者 B[k&#x2F;2-1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k&#x2F;2。</span><br><span class="line"></span><br><span class="line">    如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。</span><br><span class="line"></span><br><span class="line">    如果 k&#x3D;1，我们只要返回两个数组首元素的最小值即可。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看代码，首先index1=m就很好的预防了越界的可能性，再者使用<code>min(index1 + k / 2 - 1, m - 1);</code>能够处理<code>index+k/2</code>在边界内与边界外的两种情况，并且<code>newIndex1 - index1 + 1</code>同样能够囊括这两种情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="keyword">int</span> newIndex1 = min(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> newIndex2 = min(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="keyword">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalLength = nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKthElement(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (getKthElement(nums1, nums2, totalLength / <span class="number">2</span>) + getKthElement(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题就算想到了方法实现也是比较复杂的。其中有很多的细节需要确定。</p>
<p>由于搜索方法就是比较好寻找第k个值的，所以将寻找中值的任务转化为寻找第k个值的任务。</p>
<p>寻找第k大的显然是一个递归的任务，虽然也可以使用迭代。】</p>
<h2 id="6-Z字形变换"><a href="#6-Z字形变换" class="headerlink" title="6. Z字形变换"></a>6. Z字形变换</h2><p>难度中等862收藏分享切换为英文接收动态反馈</p>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>



<p>总共有两种解决方案，一种是比较直接的，建立一个vector[numsRow]数组，每一个vector用于储存对应行的字母，然后按照顺序遍历string，将字母储存到对应序列中，最后将数列拼接起来。关键是生成一个1234321234这样的序列。这里复制答案的解决方法，利用一个flag来标志增减。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">rows</span><span class="params">(min(numRows, <span class="keyword">int</span>(s.size())))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> goingDown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            rows[curRow] += c;</span><br><span class="line">            <span class="comment">// 利用goingDown来标志增减，在处于第一或者最后一行时进行变换</span></span><br><span class="line">            <span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>) goingDown = !goingDown;</span><br><span class="line">            curRow += goingDown ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> row : rows) ret += row;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种方案是寻找同一行数对应位置的规律，很容易发现第一行与最后一行的规律与中间行有所不同（字母明显多了），下图为第二行的位置规律。</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0208(20201007-105959).PNG" alt="IMG_0208(20201007-105959)"></p>
<p>总结下来就是</p>
<p>​        第一行，最后一行间隔：2*(numsRow-1)</p>
<p>​        中间行间隔，两种：2*(i-1),    2*(numsRow-i)</p>
<p>总结出这个规律就很好写代码了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将z字变换划分为了3部分，第一行，最后一行与中间行，因为first,end与中间行结构有所不同</span></span><br><span class="line"><span class="comment">        无法处理numsRow==1的情况，因为2*(numRows-1)间隔规律在numsRow==1时不可用</span></span><br><span class="line"><span class="comment">        在2到n-1行中，利用m来切换不同规律的间隔。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="comment">// first</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();i+=<span class="number">2</span>*(numRows<span class="number">-1</span>))&#123;</span><br><span class="line">            ret.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 to end-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= numRows<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">1</span>,loc=i<span class="number">-1</span>; loc&lt;s.size(); )&#123;</span><br><span class="line">                ret.push_back(s[loc]);</span><br><span class="line">                m%<span class="number">2</span> == <span class="number">0</span> ? loc+=<span class="number">2</span>*(i<span class="number">-1</span>) : loc+=<span class="number">2</span>*(numRows-i);</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// end</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = numRows<span class="number">-1</span>; i &lt; s.size(); i+=<span class="number">2</span>*(numRows<span class="number">-1</span>))&#123;</span><br><span class="line">            ret.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h4><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>这道题的主要难点是判断溢出，如果不经过检查就进行运算，可能会出现算术溢出的问题，并且程序会报错。</p>
<p>可以使用提前检查的方法来判断整数是否会溢出。推导可以看<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/">整数反转官方解答</a></p>
<p>关于pop为7和-8的原因是，int范围<code>(-2,147,483,648 ~ 2,147,483,647)</code>，当<code>result == INT_MAX/10</code>时，无法确定加上pop之后是否会溢出，所以需要对最后一位进行检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pop,result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            pop = x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(result &gt; INT_MAX/<span class="number">10</span> || (result == INT_MAX/<span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(result &lt; INT_MIN/<span class="number">10</span> || (result == INT_MIN/<span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result = result*<span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h4><p>难度中等1353收藏分享切换为英文接收动态反馈</p>
<p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。 </p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>



<p>拿到这道题后，自然的就将示例中的生成过程画了颗树</p>
<img src="leetcode总结/IMG_0209(20201007-161520).PNG" alt="IMG_0209(20201007-161520)" style="zoom: 25%;" />

<p>画出这张图就有思路了，就是按照画图时的过程递归的调用函数就行，即</p>
<pre><code>当已分配的左括号数量多于右括号数量，且两种括号均有剩余时，就有两种分配方法。

当已分配的左括号数量等于右括号数量，只能分配左括号（不然出现非法括号）。

当左括号分配完毕，右括号有剩余，分配右括号。</code></pre>
<p>上述的分配规律可以发现左括号分配数量必须是大于等于右括号的。</p>
<p>找到了分配规律，接下来考虑递归函数的设计：</p>
<p>首先函数需要的信息：剩余做括号数量r0， 剩余右括号数量r1，左右括号数量的差值（这个不需要作为参数，r1-r0即可计算）。伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if r0&#x3D;&#x3D;0, r1&#x3D;&#x3D;0 		记录分配,return</span><br><span class="line">if r0&#x3D;&#x3D;0, r1&gt;0 	f(r0, r1-1)</span><br><span class="line">if r0&gt;0, r1&gt;0, r1&gt;r0	f(r0, r1-1), f(r0-1, r1)</span><br><span class="line">if r0&gt;0, r1&gt;0, r1&#x3D;&#x3D;r0	f(r0-1, r1)</span><br><span class="line">注：这里的调用使用会符合约束r1 &gt; r0</span><br></pre></td></tr></table></figure>

<p>但是这样是有问题的，我们需要无法通过这样的函数来记录当前括号分配的状态。所以需要一个string变量记录当前的分配情况。f(r0, r1, s)</p>
<p>但这样还不够，最后我们需要返回结果，这里就是需要将<strong>记录分配</strong>这一步骤完成，这里可以利用一个引用的数组来完成，并且将结果记录在这个数组中。最后f原型为<code>f(r0, r1, s, &amp;result)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        f(n,n,<span class="string">&quot;&quot;</span>, result);</span><br><span class="line">        <span class="comment">// sort(result.begin(), result.end());</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> r0, <span class="keyword">int</span> r1, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="number">0</span> &amp;&amp; r0 == <span class="number">0</span>)</span><br><span class="line">            ret.push_back(s);</span><br><span class="line">        <span class="keyword">if</span>(r0 == <span class="number">0</span> &amp;&amp; r1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            f(r0, r1<span class="number">-1</span>, s+<span class="string">&#x27;)&#x27;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r0 &gt; <span class="number">0</span> &amp;&amp; r1 &gt; <span class="number">0</span> &amp;&amp; r1 &gt; r0)&#123;            </span><br><span class="line">            f(r0, r1<span class="number">-1</span>, s+<span class="string">&#x27;)&#x27;</span>, ret);</span><br><span class="line">            f(r0<span class="number">-1</span>, r1, s+<span class="string">&#x27;(&#x27;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r0 &gt; <span class="number">0</span> &amp;&amp; r1 &gt; <span class="number">0</span> &amp;&amp; r1 == r0)&#123;</span><br><span class="line">            f(r0<span class="number">-1</span>, r1, s+<span class="string">&#x27;(&#x27;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在看完解答的回溯法后，我将自己的方法与回溯法的思路进行了比对，发现了不同之处：</p>
<pre><code>我的方法中每个if之间都是互斥的。我的方法每一个if中都会对所有可能性进行探索。

回溯法每个if之间不是互斥的，这就意味着函数可能进入多个if中。回溯法每个if并不一定是对结果的完全探索，但是可以通过进入多个if中探索所有可能。</code></pre>
<p>利用回溯的思路对代码进行改造后如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        f(n,n,<span class="string">&quot;&quot;</span>, result);</span><br><span class="line">        <span class="comment">// sort(result.begin(), result.end());</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// void f(int r0, int r1, string s, vector&lt;string&gt;&amp; ret)&#123;</span></span><br><span class="line">    <span class="comment">//     if(r1 == 0 &amp;&amp; r0 == 0)</span></span><br><span class="line">    <span class="comment">//         ret.push_back(s);</span></span><br><span class="line">    <span class="comment">//     if(r0 == 0 &amp;&amp; r1 &gt; 0)&#123;</span></span><br><span class="line">    <span class="comment">//         f(r0, r1-1, s+&#x27;)&#x27;, ret);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if(r0 &gt; 0 &amp;&amp; r1 &gt; 0 &amp;&amp; r1 &gt; r0)&#123;            </span></span><br><span class="line">    <span class="comment">//         f(r0, r1-1, s+&#x27;)&#x27;, ret);</span></span><br><span class="line">    <span class="comment">//         f(r0-1, r1, s+&#x27;(&#x27;, ret);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if(r0 &gt; 0 &amp;&amp; r1 &gt; 0 &amp;&amp; r1 == r0)&#123;</span></span><br><span class="line">    <span class="comment">//         f(r0-1, r1, s+&#x27;(&#x27;, ret);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> r0, <span class="keyword">int</span> r1, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="number">0</span> &amp;&amp; r0 == <span class="number">0</span>)</span><br><span class="line">            ret.push_back(s);</span><br><span class="line">        <span class="keyword">if</span>(r0 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            f(r0<span class="number">-1</span>, r1, s+<span class="string">&#x27;(&#x27;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r1 &gt; r0)&#123;</span><br><span class="line">            f(r0, r1<span class="number">-1</span>, s+<span class="string">&#x27;)&#x27;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到回溯法会按照操作进行划分<code>f(r0-1, r1, s+&#39;(&#39;, ret);加左括号</code>， <code>f(r0, r1-1, s+&#39;)&#39;, ret);加右括号</code>。我的方法是按照进入条件划分的。</p>
<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p>难度中等947收藏分享切换为英文接收动态反馈</p>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<img src="leetcode总结/17_telephone_keypad.png" alt="img" style="zoom:50%;" />

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<p>这道题也是典型的回溯题目，根据<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88.md">回溯算法详解</a>介绍的解法框架，可以很快得出答案。</p>
<p>解法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        backtrack(digits, <span class="string">&quot;&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> digits, <span class="built_in">string</span> alpha, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ret_str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; digit_map = &#123;</span><br><span class="line">            <span class="built_in">make_pair</span>(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>),</span><br><span class="line">            <span class="built_in">make_pair</span>(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (digits.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(alpha.size() != <span class="number">0</span>)</span><br><span class="line">                ret_str.push_back(alpha);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">string</span> i = digit_map[digits[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> iter : i)&#123;</span><br><span class="line">                backtrack(digits.substr(<span class="number">1</span>), alpha+iter, ret_str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p>难度简单1315收藏分享切换为英文接收动态反馈</p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>



<p>这道题比较简单，主要是为合并K个升序链表做铺垫</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h4><p>难度困难949收藏分享切换为英文接收动态反馈</p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>



<p>这道题即是上一题的加强版，不过要寻找最优解还是需要思考的。</p>
<p>首先对合并两个有序列表的时间复杂度进行分析，最坏情况，两个链表同时分配完，复杂度为$O(m+n)$。</p>
<p>如果简单的，逐一对链表进行合并，假设长度均为n，k个链表，则总时间复杂度为<br>$$<br>O(n+2n+3n…kn)=O(nk^2)<br>$$<br>这时候就会发现了，那一个长的链表与一个短的合并，并不划算，短的链表与短的链表合并能够减少一定的时间复杂度，保持原来的假设不变，将短的两个链表先进行合并这就是第二种思路，如下图</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0216(20201012-210205).PNG" alt="IMG_0216(20201012-210205)"></p>
<p>这样合并的方式复杂度如下：<br>$$<br>O(\underset{logk个}{2n<em>\frac{k}{2}+4n</em>\frac{k}{4}+…})=O(nklogk)<br>$$<br>降低了时间复杂度。</p>
<p>不过这个方法也会有一个潜在问题， 那就是认为每一层的链表长度是接近甚至一致的，但是实际情况可能同一层不同的链表长度差距会很大，在一些极端情况下他会退化为$O(nk^2)$</p>
<p>第三种思路就是，直接合并k个链表，这样就需要比对每个链表头元素的最大值，这里采用顺序搜索的方法，每次找到最大值的的时间是$O(k)$，而一共有$nk$个值，所以需要总时间复杂度为$O(nk^2)$。</p>
<p>进一步可以想，能不能优化对最大值的搜索速度呢，这里就想到了典型的快速搜索最大最小值的优先队列，其插入，删除的时间复杂度均为$O(logn)$。通过维护一个大小为$k$的优先队列，每次对队列进行get_top与insert的操作，就能保证优先队列的头是我们需要的，那么对每个元素所花费的时间就降到了$2*logk$，总时间复杂度为$O(nklongk)$，这就是第四种方法。</p>
<p>接下来是代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;    <span class="comment">// 直接合并</span></span><br><span class="line">        <span class="keyword">if</span> (lists.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(lists.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 取最后两个，合并</span></span><br><span class="line">            ListNode* l1 = lists.back();</span><br><span class="line">            lists.pop_back();</span><br><span class="line">            ListNode* l2 = lists.back();</span><br><span class="line">            lists.pop_back();</span><br><span class="line">            lists.push_back(merge_two_list(l1, l2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge_two_list</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;   <span class="comment">// 逐层合并</span></span><br><span class="line">        <span class="keyword">if</span> (lists.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(lists.size() &gt; <span class="number">1</span>)&#123;    <span class="comment">// 如果链表数为1，完成</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">if</span>(lists.size()%<span class="number">2</span> == <span class="number">0</span>)&#123;    <span class="comment">// 如果链表数量为偶数，则不会有剩余</span></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lists.size(); i+=<span class="number">2</span>)&#123;</span><br><span class="line">                    lists[i/<span class="number">2</span>] = merge_two_list(lists[i], lists[i+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                lists.erase(lists.begin()+i/<span class="number">2</span>, lists.end());<span class="comment">// 删掉被合并的链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;   <span class="comment">// 如果链表数量为奇数，则有一个剩余</span></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lists.size()<span class="number">-1</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">                    lists[i/<span class="number">2</span>] = merge_two_list(lists[i], lists[i+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                lists[i/<span class="number">2</span>] = lists[i];  <span class="comment">// 直接将最后一个添加到最后</span></span><br><span class="line">                lists.erase(lists.begin()+i/<span class="number">2</span>+<span class="number">1</span>, lists.end());<span class="comment">// 删掉被合并的链表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge_two_list</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优先队列的实现待完成。</p>
<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h4><p>难度困难1015收藏分享切换为英文接收动态反馈</p>
<p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>初始思路</strong></p>
<p>这道题我一开始采用了动态规划的思路，但是细节并未处理好</p>
<p>设$dp[i]=k$：以i结尾的最长有效串的长度为k</p>
<p><code>if s[i]=&#39;(&#39;                        显然有dp[i]=0</code></p>
<p><code>if s[i]=&#39;)&#39;     则去寻找dp[i-dp[i-1]-1-1]的位置开始，最长的串</code></p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0223(20201013-075936).PNG" alt="IMG_0223(20201013-075936)"></p>
<p>这样时间复杂度为$n$次搜索加上每次搜索$i-k$次，复杂度为$O(n^2)$</p>
<p>但是，这种方法过于复杂了，通过更细致的考察可以找到更优的解。</p>
<p><strong>动态规划</strong>（优化后）</p>
<p>设$dp[i]=k$：以i结尾的最长有效串的长度为k</p>
<p><code>if s[i]=&#39;(&#39;                        显然有dp[i]=0</code></p>
<p><code>if s[i]=&#39;)&#39; , s[i-1]=&#39;(&#39;        即s[i-1]与s[i]配对了，则只用找dp[i-2]</code></p>
<p><code>if s[i]=&#39;)&#39; , s[i-1]=&#39;)&#39;        这时由dp[i-1]判断：</code></p>
<p>​        <img src="leetcode%E6%80%BB%E7%BB%93/IMG_0219(20201012-231955)-1602516046699.PNG" alt="IMG_0219(20201012-231955)"></p>
<p>​        这里需要给出两个证明，一个是为什么只需要判断最后一个<img src="leetcode%E6%80%BB%E7%BB%93/IMG_0220(20201012-232154).PNG" alt="IMG_0220(20201012-232154)"></p>
<p>​        另一个是证明$dp[i-1]=0$时$dp[i]=0$<img src="leetcode%E6%80%BB%E7%BB%93/IMG_0221(20201012-232832).PNG" alt="IMG_0221(20201012-232832)"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">伪代码如下：</span><br><span class="line">if s[i]&#x3D;&#39;(&#39;</span><br><span class="line">	dp[i]&#x3D;0</span><br><span class="line">if s[i]&#x3D;&#39;(&#39; , s[i-1]&#x3D;&#39;)&#39;</span><br><span class="line">	dp[i]&#x3D;dp[i-2]+2</span><br><span class="line">if s[i]&#x3D;&#39;)&#39; , s[i-1]&#x3D;&#39;)&#39;</span><br><span class="line">	if s[a]&#x3D;&#39;(&#39;</span><br><span class="line">		dp[i]&#x3D;dp[i-1]+2</span><br><span class="line">	if s[a] &#x3D; &#39;)&#39;</span><br><span class="line">		dp[i]&#x3D;0</span><br></pre></td></tr></table></figure>

<p>有了思路之后，就可以进行编码了，编码的过程中要十分注意一些边界问题，<strong>这个算法实现时有很多访问的边界情况会造成越界的行为，这个要十分注意</strong>。可以用两种方法来解决，添加一个额外的头节点，或者是对越界行为进行检查。这里的实现使用了越界检查的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = (i<span class="number">-2</span>&gt;<span class="number">0</span> ? dp[i<span class="number">-2</span>] : <span class="number">0</span>)+<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>]+<span class="number">2</span>+ (i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;<span class="number">0</span> ? dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] : <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int longestValidParentheses(string s) &#123;</span></span><br><span class="line">    <span class="comment">//     int maxans = 0, n = s.length();</span></span><br><span class="line">    <span class="comment">//     vector&lt;int&gt; dp(n, 0);</span></span><br><span class="line">    <span class="comment">//     for (int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//         if (s[i] == &#x27;)&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             if (s[i - 1] == &#x27;(&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//                 dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2;</span></span><br><span class="line">    <span class="comment">//             &#125; else if (i - dp[i - 1] &gt; 0 &amp;&amp; s[i - dp[i - 1] - 1] == &#x27;(&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//                 dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             maxans = max(maxans, dp[i]);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return maxans;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>添加注释的是官方给出的代码，与我的实现差不多，不过省去了一些不必要的判断。</p>
<h4 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h4><p>难度简单1676收藏分享切换为英文接收动态反馈</p>
<p>给定一个排序数组，你需要在**<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>



<p>这道题比较简单，一个最容易想到的办法就是找到重复值的时候利用vector.erase删除，但是这样是比较低效率的，因为vector执行删除是将后面元素逐一复制，花费$O(n)$的时间，那样最坏情况有n个相同值，则需要花费$O(n^2)$的复杂度。</p>
<p>但是使用先定位，再删除的方法进行删除，需要花费$O(n)$的空间复杂度，不符合题目要求。</p>
<p>现在要想到一种方法，在访问该元素的同时确定其是否保留以及其保留的位置。直观的想法就是保留一个指向去重尾部的指针，一个指向当前访问位的指针。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last_loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[last_loc])&#123;</span><br><span class="line">                nums[++last_loc] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last_loc+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h4><p>难度中等1007收藏分享切换为英文接收动态反馈</p>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>



<p>这道题一开始看错题目了，以为是找到旋转的那个点，所以先写了一个函数找了那个旋转点。然后发现是进行搜索，于是就想，先找到旋转点，然后将数组划分，分别进行二分搜索。</p>
<p><strong>找旋转点的关键是发现：如果个数组中begin&gt;end，则必有旋转点。（这个在标准的解法中仍是关键）</strong></p>
<p>于是找旋转点的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. mid&#x3D;(begin+end)&#x2F;2</span><br><span class="line">2. if nums[begin] &gt; nums[mid], end &#x3D; mid</span><br><span class="line">   if nums[mid] &gt; nums[end], begin &#x3D; mid</span><br><span class="line">3. to step1</span><br></pre></td></tr></table></figure>

<p>之后就是进行二分搜索。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]==target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> rotate_point = find_rotate(nums.begin(), nums.end());</span><br><span class="line">        <span class="comment">// cout &lt;&lt; *rotate_point;</span></span><br><span class="line">        <span class="comment">// return 0;</span></span><br><span class="line">        <span class="keyword">if</span> (rotate_point == nums.end())&#123;    <span class="comment">// 如果找不到旋转点</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator location;</span><br><span class="line">            location = binary_search(nums.begin(), nums.end(), target);</span><br><span class="line">            <span class="keyword">if</span>(location != nums.end())&#123;</span><br><span class="line">                <span class="keyword">return</span> location-nums.begin();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 找到旋转点</span></span><br><span class="line">            <span class="keyword">if</span>(  target &gt; *rotate_point || target &lt; *(rotate_point+<span class="number">1</span>)  )&#123;   <span class="comment">// target小于最小或大于最大</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator location;</span><br><span class="line">            <span class="comment">// [:rp]左半边，[rp+1:]右半边，左半边&gt;右半边</span></span><br><span class="line">            <span class="comment">// nums[0]为左半边最小值，但大于右半边所有值</span></span><br><span class="line">            <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>])&#123;  <span class="comment">// target在左半边</span></span><br><span class="line">                location = binary_search(nums.begin(), rotate_point+<span class="number">1</span>, target);</span><br><span class="line">                <span class="keyword">if</span>(location != rotate_point+<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> location-nums.begin();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                location = binary_search(rotate_point+<span class="number">1</span>, nums.end(), target);</span><br><span class="line">                <span class="keyword">if</span>(location != nums.end())&#123;</span><br><span class="line">                    <span class="keyword">return</span> location-nums.begin();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">find_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end)</span></span>&#123;  <span class="comment">// 找到旋转点位置i，即[:i],[i+1:]为升序</span></span><br><span class="line">        <span class="comment">// 包装函数，使其返回位置而不是用引用</span></span><br><span class="line">        <span class="comment">// 这里传的end是数组最后一个元素之后的位置</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator loc = end;</span><br><span class="line">        _find_rotate(begin, end<span class="number">-1</span>, loc);</span><br><span class="line">        <span class="keyword">return</span> loc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _find_rotate(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator &amp;loc)&#123;  <span class="comment">// 找到旋转点位置i，即[:i],[i+1:]为升序</span></span><br><span class="line">        <span class="comment">// 这里传的end是数组最后一个元素的位置</span></span><br><span class="line">        <span class="keyword">if</span>(end-begin &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*begin &gt; *end)&#123;    <span class="comment">// 未找到</span></span><br><span class="line">                loc = begin;</span><br><span class="line">                <span class="keyword">return</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator mid = begin + (end-begin)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(*begin &gt; *mid)&#123;</span><br><span class="line">            _find_rotate(begin, mid, loc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*mid &gt; *end)&#123;</span><br><span class="line">            _find_rotate(mid, end, loc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 包装函数，使其返回位置而不是用引用</span></span><br><span class="line">        <span class="comment">// 这里传的end是数组最后一个元素之后的位置</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator loc = end;</span><br><span class="line">        _binary_search(begin, end<span class="number">-1</span>, target, loc);</span><br><span class="line">        <span class="keyword">return</span> loc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _binary_search(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator &amp;loc)&#123;</span><br><span class="line">        <span class="comment">// 这里传的end是数组最后一个元素之后的位置</span></span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator mid = begin + (end-begin)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(*mid == target)&#123;</span><br><span class="line">            loc = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*mid &gt; target)&#123;</span><br><span class="line">            _binary_search(begin, mid<span class="number">-1</span>, target, loc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*mid &lt; target)&#123;</span><br><span class="line">            _binary_search(mid+<span class="number">1</span>, end, target, loc);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后看了答案的方法，我觉得我是sb。。。，它直接进行了二分搜索</p>
<p>我们只需要搞清楚一件事就行，只要能一次排除一半的区间，就能够进行二分搜索。而这个是可以做到的。</p>
<p><strong>找旋转点的关键是发现：如果个数组中begin&gt;end，则必有旋转点。</strong></p>
<p>通过这个我们可以很快判断出两部分是否有序，接下来，可以看到两段数组的范围</p>
<img src="leetcode总结/IMG_0226(20201013-121844).PNG" alt="IMG_0226(20201013-121844)" style="zoom: 33%;" />

<p>这其实与二分搜索一样，整数被划分为两个区间了，只不过这个区间比一般二分搜索的$(-\infty,a], [b, +\infty)$复杂些罢了。</p>
<p>下面是官方答案（答案使用了循环取代了递归函数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 每次只判断有序边，这样就与普通的二分搜索相似了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;	<span class="comment">// 左有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;	<span class="comment">// 可能在左边</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 可能在右边</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><p>难度中等692收藏分享切换为英文接收动态反馈</p>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
<p>这道题需要读懂题目中<strong>字典序</strong>的意思，将题目中的数组视为一个字符串，字典序就是其在字典中的位置，字典的比较方法就是，从左边开始，逐元素比较，当出现第一个位置不同时，返回结果，大的即为字典序大的值。</p>
<p>理解这个之后，就是对题目进行分析了。我们需要寻找一些规律：</p>
<ol>
<li><p>如果一个串中全部为降序排列，其就不存在比它更大的排列。</p>
</li>
<li><p>其修改靠前的数字对字典序造成的影响要大于修改靠后数字对字典序造成的影响。</p>
</li>
</ol>
<p>所以我们要尽量去修改靠后的位置，那如何确定位置最后的一个可以修改的位置呢？</p>
<p>​    <strong>最后一个升序</strong>：即最后一个$n[i]&lt;n[i+1]$的数。</p>
<p>证明：</p>
<p>首先它的后面均为降序，那么它后面的子串就是最大的字典序，无法再增大。</p>
<p>其次修改靠后的数字影响要小于靠前的数字，调整$i$以及$i$之后的值是对整个字典序影响最小的。</p>
<p>找到$i$后，就是要找<code>n[i:]</code>这个串中的下一个字典序，这个很好解决：</p>
<ol>
<li><p>找到<code>n[i+1：]</code>中，比<code>n[i]</code>大的最小数（这时为了保证比原字典序大）</p>
</li>
<li><p>交换其与<code>n[i]</code>，然后对<code>n[i+1：]</code>进行升序排序（保证比其他任何排列小）</p>
</li>
</ol>
<p>这里其实还有一个可以优化的地方，由于<code>n[i+1：]</code>是降序排列的，将i与找到的数直接进行交换，交换后的数组仍为降序，不过有个需要注意的地方，就是有两个相同的可交换数的时候，需要交换后面那个。</p>
<img src="leetcode总结/IMG_0234(20201015-192619).PNG" alt="IMG_0234(20201015-192619)" style="zoom:50%;" />

<p>之后就只需要将算法写成代码就好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到最后一个升序</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last_ascend = nums.end();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = nums.begin(); iter &lt; nums.end()<span class="number">-1</span>; iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*iter &lt; *(iter+<span class="number">1</span>))&#123;</span><br><span class="line">                last_ascend = iter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有升序，即为最大字典序</span></span><br><span class="line">        <span class="keyword">if</span>( last_ascend == nums.end())&#123;</span><br><span class="line">            reverse(nums.begin(), nums.end());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有升序，存在更大的字典序</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 找到比*last_ascend大的中最小的数</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator bigger_min = last_ascend+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> iter = last_ascend+<span class="number">1</span>; iter &lt; nums.end(); iter++)&#123;</span><br><span class="line">                <span class="comment">// *iter&lt;=*bigger_min保证bigger_min是最后一个符合的数字</span></span><br><span class="line">                <span class="keyword">if</span>( *iter&gt;*last_ascend &amp;&amp; *iter&lt;=*bigger_min )&#123;</span><br><span class="line">                    bigger_min = iter;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = *bigger_min;</span><br><span class="line">            *bigger_min = *last_ascend;</span><br><span class="line">            *last_ascend = temp;</span><br><span class="line">            <span class="comment">// 剩余的按照升序排列</span></span><br><span class="line">            <span class="comment">// sort(last_ascend+1, nums.end());</span></span><br><span class="line">            reverse(last_ascend+<span class="number">1</span>, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><p>难度中等622收藏分享切换为英文接收动态反馈</p>
<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>



<p>这道题有一种十分naive的方法，就是用二分搜索找到目标，然后在在目标左右两侧进行线性搜索。但是这种方法在一些极端情况会退化为$O(n)$，比如当target=8，数组全部为8时，所以需要找到一种更优的解决方案。</p>
<p>labuladong的<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md">二分查找详解</a>中，对二分查找有了一个比较好的整合，尤其是对边界的处理以及对于搜索区间的理解。不过，也有些东西需要补充的</p>
<p>在寻找左右边界的代码中，if (nums[mid] == target)这段我认为是没有说清楚的。下面是原文：</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/image-20201013181746024.png" alt="image-20201013181746024"></p>
<p>这个陈述我认为没有说服力，于是我自己做了小实验：</p>
<p>这段对应的原始代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现两个个事实</p>
<ol>
<li>当出现<code>nums[mid] == target</code>后，<code>nums[mid] &gt; target</code>就不会再出现了</li>
<li><code>nums[right]</code>的值永远为target</li>
</ol>
<p>这样之后的循环就可以视为只有如下两句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这两句在之后的迭代中应该是随机出现的，我们可以用程序模拟一下这个过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成100次，</span></span><br><span class="line">    <span class="comment">// 每次生成长度为300以内的随机长度的数组</span></span><br><span class="line">    <span class="comment">// 在每次选择随机选取begin = mid+1，end = mid其中一种</span></span><br><span class="line">    <span class="comment">// 观察最后begin与end的关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;  <span class="comment">//生成100次</span></span><br><span class="line">        <span class="keyword">int</span> end = rand()%<span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;end)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; end-begin &lt;&lt; &quot; | &quot;;</span></span><br><span class="line">            mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = rand();</span><br><span class="line">            <span class="keyword">if</span>(temp%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                begin = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; end-begin &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果部分图：</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/image-20201013183415194.png" alt="image-20201013183415194"></p>
<p>可以发现最后begin与end均会重合（不是所有情况都是这样，如果将代码中<code>end=mid</code>换成<code>end=mid-1</code>,可能会有-1出现）。由于<code>nums[right]</code>为target所以可以退出<code>nums[left]</code>也为target，实际上这里写返回right也没错，只不过会令人产生困惑罢了。</p>
<p>再来看使用双闭区间的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里变成了<code>right=mid-1</code>，同样可以发现两个规律；</p>
<ol>
<li>当出现<code>nums[mid] == target</code>后，<code>nums[mid] &gt; target</code>就不会再出现了</li>
<li><code>nums[right+1]</code>的值永远为target</li>
</ol>
<p>我们再做一个实验：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成100次，</span></span><br><span class="line">    <span class="comment">// 每次生成长度为300以内的随机长度的数组</span></span><br><span class="line">    <span class="comment">// 在每次选择随机选取begin = mid+1，end = mid其中一种</span></span><br><span class="line">    <span class="comment">// 观察最后begin与end的关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;  <span class="comment">//生成100次</span></span><br><span class="line">        <span class="keyword">int</span> end = rand()%<span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;=end)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; end-begin &lt;&lt; &quot; | &quot;;</span></span><br><span class="line">            mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = rand();</span><br><span class="line">            <span class="keyword">if</span>(temp%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                begin = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                end = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; end-begin &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/image-20201013184309190.png" alt="image-20201013184309190"></p>
<p>可以发现均end-begin均收敛到-1了，那么<code>right+1 == left</code>，<code>nums[left] == target</code>。返回<code>right+1</code>也行的。</p>
<p>总结一下这个边界条件的处理</p>
<p>但是，总不能每写一道题做一个实验吧，我想了下，感觉可以把常用的记录下下来，</p>
<ol>
<li><code>left&lt;=right</code>, <code>begin = mid+1</code>, <code>end = mid-1</code></li>
<li><code>left&lt;=right</code>, <code>begin = mid+1</code>, <code>end = mid</code></li>
<li><code>left&lt;=right</code>, <code>begin = mid</code>, <code>end = mid-1</code></li>
</ol>
<img src="leetcode总结/IMG_0228(20201013-191205).PNG" alt="IMG_0228(20201013-191205)" style="zoom:50%;" />

<p><code>left==right</code>情况很好由这个推出来（虽然我不咋用这个形式）</p>
<p>理清上述关系后这个算法的代码也就很简单了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = searchLeft(nums, target);</span><br><span class="line">        <span class="keyword">int</span> b = searchRight(nums, target);</span><br><span class="line">        <span class="keyword">return</span> &#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchLeft</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                end = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                begin = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                end = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= nums.size() || nums[begin] != target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> begin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchRight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                begin = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                begin = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                end = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span> || nums[end] != target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，说一下关于labuladong提供的二分搜索的模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我觉提出这种通用模块得是很好的，不过可能在<code>else if (nums[mid] &lt; target)</code>这两个条件分支可以改一下，成为更通用的即：<strong>能够将数组排除一部分的一种方法</strong>。以<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a>为例，这里的划分就不适合用target进行，但仍是一种划分的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="comment">// 每次只判断有序边，这样就与普通的二分搜索相似了</span></span><br><span class="line"><span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;	<span class="comment">// 左有序</span></span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;	<span class="comment">// 不可能在右边，可能在左边</span></span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 不可能在左边，检查右边</span></span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过他这样写可能也是为了更好让人理解，毕竟<strong>能够将数组排除一部分的一种方法</strong>这句话很容易让人困惑。</p>
<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><p>难度中等998收藏分享切换为英文接收动态反馈</p>
<p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括 <code>target</code>）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>这道题一上来就给我整蒙了，总想用什么分治，动态规划的方法来做。想了半天硬是没想出来（想的出来才怪）。结果点进答案的解决方案，看到了回溯，就退出开始自己写了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( candidates.empty() )&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">        _combinationSum(candidates, target, result, &#123;&#125;, <span class="number">0</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">ret</span><span class="params">(result.begin(), result.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cache_array, <span class="keyword">int</span> current_sum)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current_sum == target)&#123;</span><br><span class="line">            sort(cache_array.begin(), cache_array.end());</span><br><span class="line">            result.insert(cache_array);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current_sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current_sum &lt; target)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.size(); i++)&#123;</span><br><span class="line">                <span class="comment">// do</span></span><br><span class="line">                current_sum += candidates[i];</span><br><span class="line">                cache_array.push_back(candidates[i]);</span><br><span class="line">                <span class="comment">// recurrent</span></span><br><span class="line">                _combinationSum(candidates, target, result, cache_array, current_sum);</span><br><span class="line">                <span class="comment">// undo</span></span><br><span class="line">                current_sum -= candidates[i];</span><br><span class="line">                cache_array.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// /*做一个尝试，看看从大到小进行回溯会不会加快速度或者减少空间，发现并没有</span></span><br><span class="line">            <span class="comment">//   后来想了下这是肯定的，这种未进行剪枝的方法生成的回溯树都是相同的</span></span><br><span class="line">            <span class="comment">//   不会有任何区别*/</span></span><br><span class="line">            <span class="comment">// for(int i = candidates.size()-1; i &gt;= 0; i--)&#123; </span></span><br><span class="line">            <span class="comment">//     current_sum += candidates[i];                </span></span><br><span class="line">            <span class="comment">//     cache_array.push_back(candidates[i]);        </span></span><br><span class="line">            <span class="comment">//     _combinationSum(candidates, target, result, cache_array, current_sum);</span></span><br><span class="line">            <span class="comment">//     current_sum -= candidates[i];</span></span><br><span class="line">            <span class="comment">//     cache_array.pop_back();</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码结构基本上就是回溯那几个部件：退出条件，do，recurrent，undo。</p>
<p>我还是认为回溯法就是一种<strong>思路清晰的暴力解法</strong></p>
<p>然后，代码一跑出来就尴尬了，1000+ms&amp;100+MB，于是就去看了下别人的剪枝方法。</p>
<p>可以发现不管在递归的哪一层，都会出现下面这种情况：</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0232(20201015-163709).PNG" alt="IMG_0232(20201015-163709)"></p>
<p>左移，在进行for循环时，已经返回的访问过的节点可以被删除。</p>
<img src="leetcode总结/IMG_0233(20201015-164448).PNG" alt="IMG_0233(20201015-164448)" style="zoom: 33%;" />

<p>代码只需要将for循环那一部分进行一些更改就行了，不过也做了一点其他的改改动，去掉了一个不需要的参数current_sum(target一个足够了)，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( candidates.empty() )&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">        _combinationSum(candidates, target, result, &#123;&#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">ret</span><span class="params">(result.begin(), result.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates, <span class="keyword">int</span> target, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cache_array)&#123;</span><br><span class="line">        <span class="keyword">if</span>( target == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">// sort(cache_array.begin(), cache_array.end());    </span></span><br><span class="line">            result.insert(cache_array);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( target &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">// 从最大值方向向最小值方向遍历我认为有助于树的平衡</span></span><br><span class="line">            <span class="comment">// 因为数值小的一段本来就容易出现很深的树</span></span><br><span class="line">            <span class="keyword">while</span>(!candidates.empty())&#123;</span><br><span class="line">                cache_array.push_back(candidates.back());</span><br><span class="line">                _combinationSum(candidates, target-candidates.back(), result, cache_array);</span><br><span class="line">                cache_array.pop_back();</span><br><span class="line">                candidates.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// while(!candidates.empty())&#123;</span></span><br><span class="line">            <span class="comment">//     cache_array.push_back(candidates.front());</span></span><br><span class="line">            <span class="comment">//     _combinationSum(candidates, target-candidates.front(), result, cache_array);</span></span><br><span class="line">            <span class="comment">//     cache_array.pop_back();</span></span><br><span class="line">            <span class="comment">//     candidates.erase(candidates.begin(), candidates.begin()+1);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h4><p>难度困难1747收藏分享切换为英文接收动态反馈</p>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/rainwatertrap.png" alt="img"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</p>
<p>这道题的<strong>按列</strong>解题关键思路就是一个横坐标能够装水的容量取决于其左边最高与右边最高的最小值。由此可以衍生出动态规划，双指针，单调栈的解法。</p>
<p><strong>按行</strong>解题的关键思路是：任何装满水的容器均为金字塔型。</p>
<ol>
<li><p>按列解决的流程就是找到左最高与右最高，比较naive的做法就是对每个点的左右两边进行搜索，这样要花费$O(n^2)$的时间。</p>
<p>不过，可以发现这中间的结果可以保存起来，于是就有了动态规划的解法。（双指针，单调栈暂时没有看）</p>
</li>
<li><p>按行解决比较naive的方法就是对每一层进行计算，计算出每一层所能容纳的水量，这样时间复杂度为$O(n*height)$。</p>
<p>如果注意到有金字塔型的结构，就可以使用双指针，获取每一层的宽度，计算金字塔体积，然后减去所有柱子的体积即可</p>
</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// row naive solution</span></span><br><span class="line">    <span class="comment">// int trap(vector&lt;int&gt;&amp; height) &#123;</span></span><br><span class="line">    <span class="comment">//     if(height.empty())&#123;</span></span><br><span class="line">    <span class="comment">//         return 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     int max_height = *max_element(height.begin(), height.end());</span></span><br><span class="line">    <span class="comment">//     int capacity = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; max_height; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         int flag = 0;</span></span><br><span class="line">    <span class="comment">//         int temp = 0;</span></span><br><span class="line">    <span class="comment">//         for(auto iter = height.begin(); iter &lt; height.end(); iter++)&#123;</span></span><br><span class="line">    <span class="comment">//             if( flag == 0 &amp;&amp; *iter &gt; 0 )&#123;</span></span><br><span class="line">    <span class="comment">//                 flag = 1;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else if( flag == 1 &amp;&amp; *iter &lt;= 0)&#123;</span></span><br><span class="line">    <span class="comment">//                 temp++;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             else if( flag == 1 &amp;&amp; *iter &gt; 0)&#123;</span></span><br><span class="line">    <span class="comment">//                 capacity+=temp;</span></span><br><span class="line">    <span class="comment">//                 temp = 0;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             (*iter)--;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return capacity;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// // 动态规划</span></span><br><span class="line">    <span class="comment">// int trap(vector&lt;int&gt;&amp; height) &#123;</span></span><br><span class="line">    <span class="comment">//     if(height.size() &lt;= 1)&#123;</span></span><br><span class="line">    <span class="comment">//         return 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     vector&lt;int&gt; left_max(height.size(), 0);</span></span><br><span class="line">    <span class="comment">//     vector&lt;int&gt; right_max(height.size(), 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; height.size(); i++)&#123;</span></span><br><span class="line">    <span class="comment">//         left_max[i] = max(left_max[i-1], height[i-1]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for(int i = height.size()-2; i &gt;= 0; i--)&#123;</span></span><br><span class="line">    <span class="comment">//         right_max[i] = max(right_max[i+1], height[i+1]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     int capacity = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; height.size(); i++)&#123;</span></span><br><span class="line">    <span class="comment">//         capacity += min(right_max[i], left_max[i]) - height[i] &gt; 0 ? min(right_max[i], left_max[i]) - height[i] : 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return capacity;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 双指针，按行</span></span><br><span class="line">    <span class="comment">// 关键是发现填满水后的形状必是金字塔型</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.size() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> forward = height.begin();</span><br><span class="line">        <span class="keyword">auto</span> backward = height.end()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(forward &lt;= backward)&#123;</span><br><span class="line">            <span class="keyword">for</span>(; forward &lt;= backward &amp;&amp; *forward &lt;= level; forward++)&#123; </span><br><span class="line">                <span class="comment">// 这里forward &lt;= backward &amp;&amp; *forward &lt;= level必须以此顺序，</span></span><br><span class="line">                <span class="comment">// 由于可能的状态有forward==backword+1，所以直接访问*forward会可能出现越界行为</span></span><br><span class="line">                capacity -= *forward;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; forward &lt;= backward &amp;&amp; *backward &lt;= level; backward--)&#123;</span><br><span class="line">                capacity -= *backward;</span><br><span class="line">            &#125;</span><br><span class="line">            capacity += backward-forward+<span class="number">1</span>;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><p>难度中等955收藏分享切换为英文接收动态反馈</p>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>此题利用回溯法即可，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界处理</span></span><br><span class="line">        <span class="keyword">if</span>(nums.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">        _permute(nums, &#123;&#125;, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arranged, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; result)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            result.push_back(arranged);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                <span class="comment">// do</span></span><br><span class="line">                arranged.push_back(nums[i]);</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                <span class="keyword">auto</span> iter = nums.erase(nums.begin()+i);</span><br><span class="line">                <span class="comment">// recurrent</span></span><br><span class="line">                _permute(nums, arranged, result);</span><br><span class="line">                <span class="comment">// undo</span></span><br><span class="line">                nums.insert(iter, temp);</span><br><span class="line">                arranged.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h4><p>难度中等604收藏分享切换为英文接收动态反馈</p>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p><strong>说明：</strong></p>
<p>你必须在**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a><strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。</strong>请不要**使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>这道题是一道方法很容易想，关键看思路是否清晰的题目，我使用的时候逐元素旋转的方法：</p>
<p>​    内循环，完成一个环的旋转</p>
<p>​    外循环，旋转所有环</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0236(20201017-103343).PNG" alt="IMG_0236(20201017-103343)"></p>
<p>分析思路，举例子然后将中间变量提取成循环变量，首先对内循环的提取：<br>$$<br>(0,0)\rightarrow(0,n-1)\rightarrow(n-1,n-1)\rightarrow(n-1,0)\<br>(0,1)\rightarrow(1,n-1)\rightarrow(n-1, n-1-1)\rightarrow(n-1-1,0)\<br>(0,i)\rightarrow(i,n-1)\rightarrow(n-1,n-1-i)\rightarrow(n-1-i,0)\<br>$$<br>对外循环：<br>$$<br>(0+0,i+0)\rightarrow(i+0,n-1-0)\rightarrow(n-1-0,n-1-i-0)\rightarrow(n-1-i-0,0+0)\<br>(0+1,i+1)\rightarrow(i+1,n-1-1)\rightarrow(n-1-1,n-1-i-1)\rightarrow(n-1-i-1,0+1)\<br>(0+j,i+j)\rightarrow(i+j,n-1-j)\rightarrow(n-1-j,n-1-i-j)\rightarrow(n-1-i-j,0+j)\<br>$$<br>最后可以得到公式：<br>$$<br>(0+j,i+j)\rightarrow(i+j,n-1-j)\rightarrow(n-1-j,n-1-i-j)\rightarrow(n-1-i-j,0+j)\<br>$$<br>​        j：处于第几个环</p>
<p>​        i：处于这个环的第几个变量</p>
<p>​        这里在补充定义一个k方便理解：环有多少行。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; matrix[0][0];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, k = n; k &gt;= <span class="number">2</span>; k-=<span class="number">2</span>, j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                temp = matrix[j][i+j];</span><br><span class="line">    </span><br><span class="line">                matrix[j][i+j] = matrix[n<span class="number">-1</span>-j-i][j];</span><br><span class="line">                matrix[n<span class="number">-1</span>-j-i][j] = matrix[n<span class="number">-1</span>-j][n<span class="number">-1</span>-j-i];</span><br><span class="line">                matrix[n<span class="number">-1</span>-j][n<span class="number">-1</span>-j-i] = matrix[i+j][n<span class="number">-1</span>-j];</span><br><span class="line">                matrix[i+j][n<span class="number">-1</span>-j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h4><p>难度中等493收藏分享切换为英文接收动态反馈</p>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<p>第一种可以想到的方法是：将每个单词排序后的字符串作为键值，储存字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ectopic_word;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++)&#123;   <span class="comment">//利用排序后的单词作为索引</span></span><br><span class="line">            <span class="built_in">string</span> temp = strs[i];</span><br><span class="line">            sort( temp.begin(), temp.end() );</span><br><span class="line">            ectopic_word[temp].push_back(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter: ectopic_word)&#123;</span><br><span class="line">            result.push_back(iter.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设有m个单词，每个单词k个字符，排序所需要的时间为$O(mnlogn)$，将词插入哈希表的时间为$O(mn)$（每个单词哈希过程n，m个单词）。总体时间复杂度为$O(mnlogn)$。空间复杂度为$O(mn)$</p>
<p>进一步降低时间复杂度的是不使用排序后的字符串作为索引，而是直接利用$O(n)$的哈希算法建立单词索引，该哈希法需要有<strong>位置不变性</strong>。一个可行的方法是构建一个位串进行记录，每个字母对应3-4个bit。另一个方法是利用质数乘法建立索引。下面给出质数乘法的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">double</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; m;</span><br><span class="line">        <span class="keyword">double</span> a[<span class="number">26</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span>&amp; s : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> t = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : s)</span><br><span class="line">                t *= a[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            m[t].push_back(s);          <span class="comment">//t为单词对应的质数乘积，m[t]则为该单词的异位词构成的vector</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : m)                <span class="comment">//n为键和值组成的pair</span></span><br><span class="line">            res.push_back(n.second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h4><p>难度简单2542收藏分享切换为英文接收动态反馈</p>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong></p>
<p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>
<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h4><p>难度中等875收藏分享切换为英文接收动态反馈</p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>



<p>一开始想用回溯的方法去找出所有路径，然后如果有可行路径就返回，但是这样超时了。后面一想回溯完全没必要，因为利用回溯主要是想规避局部最优，但是这个题目中不存在局部最优，对于非0区域全部取1即可。</p>
<p>后面发现了一个十分关键的规律，就是只要数组中间没有0导致的断层，均可达。有0断层的，如果能跳过所有断层，也为可达。知道这个，算法就很好设计了。</p>
<p>记：<code>jp[i]</code>为第i个元素最远能到达的位置<br>$$<br>jp[i] = max(n[i], jp[i-1])<br>$$<br>遍历数组，如果中间有<code>jp[i]==0</code>，则返回false，如果jp均大于0，则返回true。</p>
<p>由于实际上只需要记录当前jp与上一个jp的值，所以利用一个变量代替。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i&lt;nums.size()<span class="number">-1</span>; i++)&#123;    <span class="comment">//计算jp直至倒数第二个数</span></span><br><span class="line">            jp = max(nums[i], jp<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(jp == <span class="number">0</span>)&#123;    <span class="comment">// 如果中间存在断层，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h4><p>难度中等655收藏分享切换为英文接收动态反馈</p>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>



<p>这道题只需要理清思路就可以了，关键是对区间进行排序，因为如果不进行排序，情况可能会十分复杂，会有3合1的情况。</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0237(20201020-173612).PNG" alt="IMG_0237(20201020-173612)"></p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() &lt;= <span class="number">1</span>)&#123;  <span class="comment">// 边界处理</span></span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge&#123;intervals.front()&#125;;   <span class="comment">// 记录合并后的数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( merge.back()[<span class="number">1</span>] &lt; intervals[i][<span class="number">1</span>] &amp;&amp; merge.back()[<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>] )&#123;</span><br><span class="line">                merge.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( merge.back()[<span class="number">1</span>] &lt; intervals[i][<span class="number">1</span>] &amp;&amp; merge.back()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>] )&#123;</span><br><span class="line">                merge.back()[<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( merge.back()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">1</span>] )&#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static bool my_compare(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)&#123;</span></span><br><span class="line">    <span class="comment">//     return (a[0] &lt; b[0]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注：对vector进行比较等价于对其第一个元素进行比较，所以这里可以直接使用sort</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度为排序复杂度$O(nlogn)$。</p>
<p>这里还有个有趣的事情，这是我第一份代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size()<span class="number">-1</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>( intervals[i][<span class="number">1</span>] &lt; intervals[i+<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; </span><br><span class="line">                intervals[i][<span class="number">1</span>] &lt; intervals[i+<span class="number">1</span>][<span class="number">0</span>] )&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( intervals[i][<span class="number">1</span>] &lt; intervals[i+<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; </span><br><span class="line">                     intervals[i][<span class="number">1</span>] &gt;= intervals[i+<span class="number">1</span>][<span class="number">0</span>] )&#123;</span><br><span class="line">                intervals[i][<span class="number">1</span>] = intervals[i+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                intervals.erase(intervals.begin()+i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( intervals[i][<span class="number">1</span>] &gt;= intervals[i+<span class="number">1</span>][<span class="number">1</span>] )&#123;</span><br><span class="line">                intervals.erase(intervals.begin()+i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是超时了，我一开始很纳闷为啥都是$O(nlogn)$我的却超时了，随后想起来是vector erase元素的复杂度导致的，erase一个元素的复杂度是$O(n)$，所以总复杂度是$O(n^2)$，所以超时了。</p>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h4><p>难度中等721收藏分享切换为英文接收动态反馈</p>
<p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/robot_maze.png" alt="img"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2 * 10 ^ 9</code></li>
</ul>
<p>这道题可以使用动态规划方法和数学方法来做，动态规划的方法中需要发现<br>$$<br>dp[i,j] = dp[i-1, j]+dp[i, j-1]\<br>dp[i,0] = 1\<br>dp[0,j] = 1<br>$$<br>数学方法，将问题转化为一共走m+n-2本书，有m-1本A书，n-1本B书，求总共有多少种摆放方法。即在m+n-2个位置中选m-1个位置，即<br>$$<br>C_{m+n-2}^{m-1}<br>$$<br>两种方法代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界情况</span></span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">2</span> || n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">grid</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 初始化，grid[0][0]值不会用上，所以随意</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            grid[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] = grid[i<span class="number">-1</span>][j]+grid[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数学方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界情况</span></span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">2</span> || n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">1</span>;	<span class="comment">//使用long防止溢出，用double也可以</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            result = result*(m+n<span class="number">-2</span>-i)/(<span class="number">1</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h4><p>难度困难1198收藏分享切换为英文接收动态反馈</p>
<p>给你两个单词 <em>word1</em> 和 <em>word2</em>，请你计算出将 <em>word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>



<p>这道题需要发现两个关键规律，才能解决，编写代码过程比较简单。</p>
<ol>
<li><p>可以将对于一个对象的插入，删除，替换的三个操作转化为面向两个对象的三个操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为 doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符 e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的 doge；</span><br><span class="line"></span><br><span class="line">同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；</span><br><span class="line"></span><br><span class="line">对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为 bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -&gt; c，和修改单词 B 的第一个字母 c -&gt; b 是等价的。</span><br><span class="line"></span><br><span class="line">最后可以减少到3个操作：</span><br><span class="line">	在单词 A 中插入一个字符；</span><br><span class="line">	在单词 B 中插入一个字符；</span><br><span class="line">	修改单词 A 的一个字符。</span><br><span class="line">或者</span><br><span class="line">	在单词 A 中删除一个字符；</span><br><span class="line">	在单词 B 中删除一个字符；</span><br><span class="line">	修改单词 A 的一个字符。</span><br><span class="line">	</span><br><span class="line">这里选择第二组操作作为说明</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设对于word1，word2有一个最少操作数的操作op，通过上面的转换可以转变为对word1的操作op1，以及对word2的操作op2。由于op1，op2是由最短序列变换而来，所以有以下特点：</p>
<p>​        一个字母不会被替换两次</p>
<p>​        一个字母不会被先替换再删除</p>
<p>其实就说明了一个序列中每个元素最多会被处理一次，或者一次都不处理。那么op1与op2都可以转换为<strong>逐元素</strong>操作，<strong>删除该元素，替换该元素，跳过该元素</strong>。由于是逐元素进行操作，<strong>op1序列的操作顺序是可以调换的</strong>，op2同理。</p>
</li>
</ol>
<p>顺序方面还是弄不清楚（待解决）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(word1.length()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(word2.length()+<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.length(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word2.length(); i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = min( min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])+<span class="number">1</span>, dp[i<span class="number">-1</span>][j<span class="number">-1</span>] );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + min( min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]), dp[i<span class="number">-1</span>][j<span class="number">-1</span>] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h4><p>难度中等683收藏分享切换为英文接收动态反馈</p>
<p>给定一个包含红色、白色和蓝色，一共 <em>n</em> 个元素的数组，**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<p>这里采用双指针解决，定义i，j分别指向两段第一个非0或2的数字，然后利用k遍历ij之间的值，将0，2分别与i，j对应的位置交换。</p>
<p>一些特殊情况需要注意，可能nums[i], nums[j], nums[k]</p>
<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><p>难度中等755收藏分享切换为英文接收动态反馈</p>
<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>递归方法与一般的迭代就不赘述了，这里记录一种巧妙的迭代方法，可以使前中后序遍历的形式统一。</p>
<p>中序遍历以及后序遍历由于其遍历的特性，对于根节点会多次经过，比如后序遍历，首先会经过根节点进入左子树，之后返回，在进入右子树，返回，才会对节点值进行访问。根节点<strong>经过</strong>了3次，最后一次才会访问，这也是造成了代码无法统一的原因，我们需要有一个记录来确定访问的这个节点是否有访问过左右子树。</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0238(20201025-205013).PNG" alt="IMG_0238(20201025-205013)"></p>
<p>现在思考以下递归是怎么实现统一的代码格式的，在递归中的方法中，函数栈可以记录下当前节点访问的进度。当函数返回时可以返回到相对应的<strong>访问状态</strong>。那么我们是否可以利用栈保存这个访问状态呢？</p>
<p>比如，中序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _inorderTraversal(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _inorderTraversal(root-&gt;left, result);</span><br><span class="line">    result.push_back(root-&gt;val);</span><br><span class="line">    _inorderTraversal(root-&gt;right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归遍历的函数过程：递归遍历根，递归遍历左，访问根，递归遍历右</p>
<p>在考虑先序遍历与后序遍历：</p>
<p>​    先序遍历：递归遍历根，访问根，递归遍历左，递归遍历右</p>
<p>​    中序遍历：递归遍历根，递归遍历左，访问根，递归遍历右</p>
<p>​    后序遍历：递归遍历根，递归遍历左，递归遍历右，访问根</p>
<p>这里都需要一个状态来标记是否是递归遍历一个节点，其余只需要改变压栈顺序，就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        WHITE, GRAY = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = [(WHITE, root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            color, node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> color == WHITE:</span><br><span class="line">                <span class="comment"># 调整这三句的顺序，不过语句顺序需要反着来</span></span><br><span class="line">                stack.append((GRAY, node))</span><br><span class="line">                stack.append((WHITE, node.right))</span><br><span class="line">                stack.append((WHITE, node.left))</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h4><p>难度中等722收藏分享切换为英文接收动态反馈</p>
<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>



<p>这道题如果使用简单的回溯方法会导致超时，需要使用动态规划进行解决。</p>
<p>回溯方法的问题在于当某个长度的子串返回true时，可能会有很多种方法，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catsand可分为cats,and	cat,sand</span><br></pre></td></tr></table></figure>

<p>但是对于后续的求解过程中我并不需要这么详细的信息，只需要知道是否有解就可以了。</p>
<p>有了这个思路，就可以构想dp的定义了，dp不需要记录<strong>怎么</strong>切分，只需要记录<strong>能否</strong>切分即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i]: 0~i的子串能否用worddict表示</span><br></pre></td></tr></table></figure>

<p>接下来尝试寻找递推关系式，一个直观的思路就是对s[ : i]中的每一种可能进行探索。<br>$$<br>(dp[j]=true) \and (s[j:j] in wordDict)\<br>        0\le j\lt i<br>$$<br>如果其中有一个是true，则dp[i] = true</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 暴力法，超時</span></span><br><span class="line">    <span class="comment">// bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span></span><br><span class="line">    <span class="comment">//     unordered_set&lt;string&gt; word_set(wordDict.begin(), wordDict.end());</span></span><br><span class="line">    <span class="comment">//     bool flag = false;</span></span><br><span class="line">    <span class="comment">//     _wordBreak(s, 0, word_set, flag);</span></span><br><span class="line">    <span class="comment">//     return flag;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// void _wordBreak(string &amp;s,int pos, unordered_set&lt;string&gt;&amp; word_set, bool&amp; flag)&#123;</span></span><br><span class="line">    <span class="comment">//     if(pos == s.size() || flag == true)&#123;</span></span><br><span class="line">    <span class="comment">//         flag = true;</span></span><br><span class="line">    <span class="comment">//         return;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     // for(int i = pos; i &lt; s.size(); i++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(int i = s.size()-1; i &gt;= pos; i--)&#123;</span></span><br><span class="line">    <span class="comment">//         if(word_set.count(s.substr(pos, i-pos+1)) &gt; 0)&#123;// 找到了相同的詞</span></span><br><span class="line">    <span class="comment">//             _wordBreak(s, i+1, word_set, flag);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span> || wordDict.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">word_set</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="comment">// dp[i]: [0,i]能否用wordDict表示，左右闭区间</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="comment">// 计算dp[i]</span></span><br><span class="line">            <span class="keyword">if</span>( word_set.count(s.substr(<span class="number">0</span>,i+<span class="number">1</span>)) &gt; <span class="number">0</span> )&#123;  <span class="comment">// 先检查是否有前面所有字符是否在wordDict内，相当于检查dp[-1]</span></span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( dp[j] &amp;&amp; word_set.count(s.substr(j+<span class="number">1</span>, i-j)) )&#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h4><p>难度简单833收藏分享切换为英文接收动态反馈</p>
<p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>进阶：</strong></p>
<p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p>
<p>这道题引入了一种新的双指针方法，快慢指针，并非等距离，而是利用移动速度不同来进行的，当两个指针都进入一个环后，快指针一定会与慢指针相遇。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// // naive way</span></span><br><span class="line">    <span class="comment">// bool hasCycle(ListNode *head) &#123;</span></span><br><span class="line">    <span class="comment">//     unordered_set&lt;ListNode* &gt; s;</span></span><br><span class="line">    <span class="comment">//     ListNode *p = head;</span></span><br><span class="line">    <span class="comment">//     while(s.count(p)==0 &amp;&amp; p!=nullptr)&#123;</span></span><br><span class="line">    <span class="comment">//         s.insert(p);</span></span><br><span class="line">    <span class="comment">//         p = p-&gt;next;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return p?true:false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// slow fast pointer</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow &amp;&amp; fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><p>难度中等733收藏分享切换为英文接收动态反馈</p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li>
</ul>
<p>进阶的算法设计的十分巧妙，没有想到，这里记录一下自己的方法以及答案的方法。</p>
<p>我自己的方法的关键思路是，一个环中的点移动环大小的步数后，指针值不变。实现方法是，找到环的大小，之后对每个点进行环大小数量的移动。如果指针值一致则这个点在环内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = find_loop_size(head);</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试函数</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; in_cycle(head-&gt;next-&gt;next-&gt;next, count);</span></span><br><span class="line">    ListNode *p1 = head;</span><br><span class="line">    <span class="keyword">while</span>( !in_cycle(p1,count) )&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_loop_size</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    <span class="comment">// 使两个指针重合</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_cycle</span><span class="params">(ListNode* node, <span class="keyword">int</span> cycle_size)</span></span>&#123;</span><br><span class="line">    ListNode *p = node;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cycle_size; i++)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == node ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU缓存机制</a></h4><p>难度中等967收藏分享切换为英文接收动态反馈</p>
<p>运用你所掌握的数据结构，设计和实现一个 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存机制</a>。它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>
<p>获取数据 <code>get(key)</code> - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p><strong>进阶:</strong></p>
<p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p>
<p>首先我们整理以下get与put所需要的操作：</p>
<p>get:</p>
<ol>
<li>寻找&lt;key, value&gt;</li>
<li>如果找到，更新优先级，返回value</li>
<li>如果未找到，返回-1，</li>
</ol>
<p>put:</p>
<ol>
<li>寻找&lt;key, value&gt;</li>
<li>如果找到，更新优先级，返回</li>
<li>如果未找到：<ol>
<li>未找到且未满，将&lt;key, value&gt;插入，设置优先级。</li>
<li>未找到且已满，删除LRU的&lt;key, value&gt;，将put中的&lt;key, value&gt;插入，设置优先级</li>
</ol>
</li>
</ol>
<p>根据这些操作的特点我们来考虑LRU需要的数据结构</p>
<p>要实现LRU需要一个队列，如果使用数组进行设计，但即使使用deque可以解决对头尾插入，删除的问题，对元素的移动（更新优先级）时的复杂度仍为$O(n)$。考虑链表实现，对元素的移动以及插入删除都有很好的效率，但是查找需要花费$O(n)$的时间。</p>
<p>而进阶的要求需要$O(1)$的时间复杂度。对于数组中元素移动我们是无法做优化的，而搜索方面，我们可以建立索引来优化查找速度。想要达到$O(1)$的搜索速度，我们就需要建立哈希索引。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt; <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; node; <span class="comment">// key,value</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt; <span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;::iterator &gt; index; <span class="comment">//&lt;key, pointer&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>list储存k, v，unordered_map储存key以及指向list的pointer。每次查找对umap进行，对于删除头，尾节点需要保存两个指针，不过我们使用list实现队列，list自动保存begin与end位置，所以就不需要了。</p>
<h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h4><p>难度简单710收藏分享切换为英文接收动态反馈</p>
<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li><code>push(x)</code> —— 将元素 x 推入栈中。</li>
<li><code>pop()</code> —— 删除栈顶的元素。</li>
<li><code>top()</code> —— 获取栈顶元素。</li>
<li><code>getMin()</code> —— 检索栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>
</ul>
<p>这套题目如果要使空间复杂度降到$O(1)$，需要一个很巧妙的方法</p>
<p>注意到，辅助栈中的最小值储存的值有很多是一致的，当前数字比最小值大时，不会改变最小值。并且辅助栈的数值一定是从大到小的，那么我们就可以尝试一种方法，只记录辅助栈的变化。</p>
<p>但是这样还是$o(n)$空间复杂度的，因为不能保证辅助栈是否一直在变，这就需要设计一种很巧妙的方法了</p>
<p>该方法只需要一个辅助空间，那么如何在pop之后从栈顶以及该辅助空间推出下一个最小元素值就成了关键。</p>
<p>设计如下：</p>
<p>该辅助空间始终保存min_elem，push一个新的值时x，<strong>若新值大于min_elem</strong>，栈空间用于保存其与min_elem的差值（x-min_elem），这里的min_elem由于没有变化。</p>
<p>当push的<strong>新值x小于min_elem</strong>时，min_elem更新为x，这时栈空间就不需要保存x的值了，因为x的值可以从min_elem中获取，这时x需要保存的是原来的min_elem于现在的min_elem的差值（x-min_elem），这是为了在pop过程中能够得到原来的min_elem。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(1)空间复杂度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(min_stack.empty())&#123;<span class="comment">// 初始情况，当栈空时，以（最小值差值+最小值）记录</span></span><br><span class="line">            min_elem = x;</span><br><span class="line">            min_stack.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// min_elem始终记录最小值</span></span><br><span class="line">            <span class="comment">// min_stack记录与上一个最小值的差值</span></span><br><span class="line">            min_stack.push_back(x-min_elem);</span><br><span class="line">            x-min_elem &gt;= <span class="number">0</span> ? : min_elem = x; <span class="comment">// x-min_elem 有溢出风险</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据stacktop的正负，有所不同</span></span><br><span class="line">        <span class="comment">// 为正则代表当前值插入时并未改变min_elem，并且记录的是与上一个也是当前min_elem的差值</span></span><br><span class="line">        <span class="comment">// 为负则代表当前值插入时改变了min_elem，栈顶记录的是与上一个min_elem的差值，而当前的min_elem就是该值</span></span><br><span class="line">        min_stack.back() &gt; <span class="number">0</span> ? : min_elem-=min_stack.back();</span><br><span class="line">        min_stack.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据stacktop的正负，有所不同</span></span><br><span class="line">        <span class="comment">// 为正则代表当前值插入时并未改变min_elem，并且记录的是与上一个也是当前min_elem的差值</span></span><br><span class="line">        <span class="comment">// 为负则代表当前值插入时改变了min_elem，栈顶记录的是与上一个min_elem的差值，而当前的min_elem就是需要return的值</span></span><br><span class="line">        <span class="keyword">return</span> min_stack.back()&gt;<span class="number">0</span> ? min_stack.back()+min_elem : min_elem;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_elem;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这里使用long是防止int数据溢出，在x-min_elem处如INT_MIN-INT_MAX就会溢出</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; min_stack;</span><br><span class="line">    <span class="keyword">long</span> min_elem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不过这里有一个潜在的问题x-min_elem会有整型溢出的可能，之所以采用long也是因为这个原因，但是使用long不就和辅助栈的空间差不多了。。。。感觉可行的方法就是对输入做一些限制。不过这里测试用例就有边界值的条件，所以无法做此限制。</p>
<h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></h4><p>难度简单780收藏分享切换为英文接收动态反馈</p>
<p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>



<p>这道题如果仅仅是做出来是比较简单的，这里主要将投票算法。投票算法的用大白话将就是当一个势力超过了整体的一半时，即使剩下的势力团结起来，也不是对手。</p>
<p>投票算法过程很简单：</p>
<ol>
<li><p>首先拥有一个候选人席位，当前得票数最多的当选。</p>
</li>
<li><p>每个数字会投该数字一票，如果有相同的数字则会让这个数字的票数加1，反之减一。</p>
</li>
<li><p>如果当前候选的数字的票数为0，则下一个数字会将候选人席位夺走。</p>
</li>
<li><p>所有数字依次投票，最后的候选者当选。</p>
</li>
</ol>
<p>这个算法的正确性可以用反证法证明，如果数字x是多数派（即超过一半），个数为k，且未当选。那么x所得到的票数为k，失去的票数至少为k+1，则意味着有k+1个不是x的数字，推出x不是多数派，矛盾。</p>
<p>编码过程十分简单，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// hash table</span></span><br><span class="line">    <span class="comment">// int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line">    <span class="comment">//     map&lt;int, int&gt; elem_num;</span></span><br><span class="line">    <span class="comment">//     for(auto n: nums)&#123;</span></span><br><span class="line">    <span class="comment">//         elem_num[n]+=1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     pair&lt;int,int&gt;max_num&#123;0,0&#125;;</span></span><br><span class="line">    <span class="comment">//     for(auto e: elem_num)&#123;</span></span><br><span class="line">    <span class="comment">//         if(e.second &gt; max_num.second)&#123;</span></span><br><span class="line">    <span class="comment">//             max_num = e;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return max_num.first;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// Boyer-Moore vote</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">int</span> cand = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == cand)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// nums[i] != cand</span></span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                    cand = nums[i];</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">// count &gt; 0</span></span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h4><p>难度简单1139收藏分享切换为英文接收动态反馈</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<p>简单的动态规划题目，</p>
<p>这里可以总结一下dp的一些步骤。</p>
<p>首先，dp的题目通常是让你找最优的（找最优不一定用dp）</p>
<p>其次你所定义的$$dp[i]$$一定要能够从$$dp[i-1],dp[i-2]…dp[1]$$中推出来即<br>$$<br>dp[i] =  f(dp[i-1], dp[i-2]…dp[1])<br>$$<br>还有递推关系要相对简单（这个是理所当然的，不简单也不容易找这个$f$啊）。</p>
<p>dp题目如果能定义出$$dp[i]$$，并能找到$$f$$就已经成功一大半了。</p>
<p>$$dp[i]$$的定义一是要简单，二是$$dp[i]$$一定要能覆盖到所求的答案的所有可能，因为本质上dp就是一种特殊的穷举，只不过很好的利用了中间信息减少时间复杂度罢了。或者说，dp就是一个具有一个剪枝策略的回溯法。就拿我构建的子问题与答案构建的子问题举例：</p>
<ol>
<li><p>答案对$$dp[k]$$的构建是：偷窃0-k间房子的最高金额</p>
</li>
<li><p>我所定义的$$dp[k]$$是：偷窃0~k间房子且偷窃第k间房子的最高金额</p>
</li>
</ol>
<p>答案显然是对所有可能的全覆盖。而所得到的最高金额必须是一组偷窃的房子，假设最后一个房子为x，那么解一定是我所定义的$$dp[x]$$，即在我所定义的$$dp[1~n]$$中。所以这两种方法均是对解的全覆盖。</p>
<p>关于dp空间的优化，主要就是减少不必要的cache，只保存递推的必要元素，不需要的可以舍弃，就那答案的递归关系式定义来说：<br>$$<br>dp[i]=max(dp[i−2]+nums[i],dp[i−1])<br>$$<br>这里只需要保存$$dp[i-1]$$，$$dp[i-2]$$就可以了，而不需要将整个$$dp[1-n]$$全部保存。</p>
<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h4><p>难度中等838收藏分享切换为英文接收动态反馈</p>
<p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<p>这道题一开始尝试使用dp来解答，但是发现这个方法不可行，这里记录下思考过程。</p>
<p>定义$$dp[m,n]$$: $$grid[0-m, 0-n]$$的岛屿数量。 </p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0256(20201103-114503).PNG" alt="IMG_0256(20201103-114503)"></p>
<p>明智的方式是使用dfs或者bfs进行，具体可以看标准答案，讲的很清楚，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // dfs</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span></span><br><span class="line"><span class="comment">//         int count = 0;</span></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; grid.size(); i++)&#123;</span></span><br><span class="line"><span class="comment">//             for(int j = 0; j &lt; grid[0].size(); j++)&#123;</span></span><br><span class="line"><span class="comment">//                 if(grid[i][j] != &#x27;0&#x27;)&#123;</span></span><br><span class="line"><span class="comment">//                     dfs(i,j, &amp;grid);</span></span><br><span class="line"><span class="comment">//                     count++;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return count;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void dfs(int i, int j, vector&lt;vector&lt;char&gt;&gt; *grid)&#123;</span></span><br><span class="line"><span class="comment">//         (*grid)[i][j] = &#x27;0&#x27;;</span></span><br><span class="line"><span class="comment">//         if( i-1&gt;=0 &amp;&amp; (*grid)[i-1][j]==&#x27;1&#x27; ) dfs(i-1, j, grid);</span></span><br><span class="line"><span class="comment">//         if( i+1&lt;grid-&gt;size() &amp;&amp; (*grid)[i+1][j]==&#x27;1&#x27; ) dfs(i+1, j, grid);</span></span><br><span class="line"><span class="comment">//         if( j-1&gt;=0 &amp;&amp; (*grid)[i][j-1]==&#x27;1&#x27; ) dfs(i, j-1, grid);</span></span><br><span class="line"><span class="comment">//         if( j+1&lt;(*grid)[0].size() &amp;&amp; (*grid)[i][j+1]==&#x27;1&#x27; )dfs(i, j+1, grid);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// init</span></span><br><span class="line">                    q.push_back(&#123;i, j&#125;);</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//这里有个细节，不能先将&#123;i,j&#125;push,然后在循环中把grid[i][j]至为0,因为这样会出现很多重复的节点,</span></span><br><span class="line">                    <span class="comment">//可能同处于第k步的两个节点下一步会有一样的位置,这样就会带来很大的冗余,在一些测试用例中会超时</span></span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                        <span class="keyword">int</span> i = q.front().first;</span><br><span class="line">                        <span class="keyword">int</span> j = q.front().second;</span><br><span class="line">                        q.pop_front();</span><br><span class="line">                        <span class="keyword">if</span>( i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j]==<span class="string">&#x27;1&#x27;</span> ) q.push_back(&#123;i<span class="number">-1</span>, j&#125;), grid[i<span class="number">-1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span>( i+<span class="number">1</span>&lt;grid.size() &amp;&amp; grid[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span> ) q.push_back(&#123;i+<span class="number">1</span>, j&#125;), grid[i+<span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span>( j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span> ) q.push_back(&#123;i, j<span class="number">-1</span>&#125;), grid[i][j<span class="number">-1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span>( j+<span class="number">1</span>&lt;grid[<span class="number">0</span>].size() &amp;&amp; grid[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span> ) q.push_back(&#123;i, j+<span class="number">1</span>&#125;), grid[i][j+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h4><p>难度中等449收藏分享切换为英文接收动态反馈</p>
<p>实现一个 Trie (前缀树)，包含 <code>insert</code>, <code>search</code>, 和 <code>startsWith</code> 这三个操作。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>你可以假设所有的输入都是由小写字母 <code>a-z</code> 构成的。</li>
<li>保证所有输入均为非空字符串。</li>
</ul>
<p>记录一下这道题目的思考过程。首先是整体使用树型结构储存，对一个trie的搜索的时间复杂度就是：*<em>每一层搜索的时间</em>层数**</p>
<p>关键就是如何设计兄弟节点的储存方法，下面是分析</p>
<p>这里做一些说明：</p>
<ol>
<li><p>每一个节点是代表对单独字符的查找时间如果查找apple这个字符串，整体的查找时间会变为$$O(n*min(m,x))$$</p>
</li>
<li><p>插入一个节点仅仅是说对一个确定位置的插入，而对trie的插入需要先查找定位，再进行插入。</p>
</li>
</ol>
<p><img src="leetcode%E6%80%BB%E7%BB%93/B0CE192CAF10C22F4E88028E6B19F0C7.png" alt="B0CE192CAF10C22F4E88028E6B19F0C7"></p>
<p>如果单词数量很多的情况下，x对空间复杂度的增加就可以视作一个常数，并且其对查找插入的速度有巨大的增幅所以这里我们使用哈希储存的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie(): is_word(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            child_node[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// memset(child_node, 0, 26*sizeof(child_node));</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie *p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child_node[word[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                Trie *temp = <span class="keyword">new</span> Trie;</span><br><span class="line">                p-&gt;child_node[word[i]-<span class="string">&#x27;a&#x27;</span>] = temp;</span><br><span class="line">                p = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;child_node[word[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie *p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child_node[word[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;child_node[word[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;is_word;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie *p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child_node[prefix[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;child_node[prefix[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> is_word;</span><br><span class="line">    Trie* child_node[<span class="number">26</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></h4><p>难度困难652收藏分享切换为英文接收动态反馈</p>
<p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>
<p><strong>示例 1：</strong></p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/maximal.jpg" alt="img"></p>
<p>记录一个失败的方法：</p>
<p>使用dp[i,j]：以(i,j)为左上定点的最大矩形，从右下开始计算。该方法不可行。</p>
<p><img src="leetcode%E6%80%BB%E7%BB%93/IMG_0276(20201123-221129).PNG" alt="IMG_0276(20201123-221129)"></p>
<h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h4><p>对单项链表的操作，一般都是持有其前一个节点prep，然后将prep-&gt;next传入函数中。</p>
<p>对单链表进行翻转的时间复杂度为O(n)</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/05/c++%E5%A4%A7%E6%9D%82%E7%83%A9/c++%20lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="prev" title="c++ const与constexpr区别">
      <i class="fa fa-chevron-left"></i> c++ const与constexpr区别
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/20/%E5%AE%A2%E6%88%B7%E6%9C%BA(ubuntu)%E5%A6%82%E4%BD%95ssh%E8%BF%9E%E6%8E%A5vmware/" rel="next" title="客户机如何ssh连接vmware（ubuntu）">
      客户机如何ssh连接vmware（ubuntu） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">104.二叉树最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95"><span class="nav-number">1.0.1.</span> <span class="nav-text">递归方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="nav-number">1.0.2.</span> <span class="nav-text">迭代方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-10-01-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">面试题 10.01. 合并排序的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0"><span class="nav-number">3.</span> <span class="nav-text">836. 矩形重叠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">4.</span> <span class="nav-text">221. 最大正方形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">5.</span> <span class="nav-text">5. 最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1248-%E7%BB%9F%E8%AE%A1%E3%80%8C%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%8D"><span class="nav-number">6.</span> <span class="nav-text">1248. 统计「优美子数组」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#466-%E7%BB%9F%E8%AE%A1%E9%87%8D%E5%A4%8D%E4%B8%AA%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">466. 统计重复个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">11. 盛水最多的容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">9.</span> <span class="nav-text">1. 两数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">10.</span> <span class="nav-text">15. 三数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">11.</span> <span class="nav-text">2. 两数相加</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">12.</span> <span class="nav-text">4. 寻找两个正序数组的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="nav-number">13.</span> <span class="nav-text">6. Z字形变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">13.0.1.</span> <span class="nav-text">7. 整数反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">13.0.2.</span> <span class="nav-text">22. 括号生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">13.0.3.</span> <span class="nav-text">17. 电话号码的字母组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">13.0.4.</span> <span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">13.0.5.</span> <span class="nav-text">23. 合并K个升序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-number">13.0.6.</span> <span class="nav-text">32. 最长有效括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">13.0.7.</span> <span class="nav-text">26. 删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">13.0.8.</span> <span class="nav-text">33. 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">13.0.9.</span> <span class="nav-text">31. 下一个排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">13.0.10.</span> <span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">13.0.11.</span> <span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">13.0.12.</span> <span class="nav-text">42. 接雨水</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">13.0.13.</span> <span class="nav-text">46. 全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">13.0.14.</span> <span class="nav-text">48. 旋转图像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">13.0.15.</span> <span class="nav-text">49. 字母异位词分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="nav-number">13.0.16.</span> <span class="nav-text">53. 最大子序和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">13.0.17.</span> <span class="nav-text">55. 跳跃游戏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">13.0.18.</span> <span class="nav-text">56. 合并区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">13.0.19.</span> <span class="nav-text">62. 不同路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">13.0.20.</span> <span class="nav-text">72. 编辑距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="nav-number">13.0.21.</span> <span class="nav-text">75. 颜色分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">13.0.22.</span> <span class="nav-text">94. 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">13.0.23.</span> <span class="nav-text">139. 单词拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">13.0.24.</span> <span class="nav-text">141. 环形链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-number">13.0.25.</span> <span class="nav-text">142. 环形链表 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">13.0.26.</span> <span class="nav-text">146. LRU缓存机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-number">13.0.27.</span> <span class="nav-text">155. 最小栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">13.0.28.</span> <span class="nav-text">169. 多数元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">13.0.29.</span> <span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">13.0.30.</span> <span class="nav-text">200. 岛屿数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">13.0.31.</span> <span class="nav-text">208. 实现 Trie (前缀树)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="nav-number">13.0.32.</span> <span class="nav-text">85. 最大矩形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">13.0.33.</span> <span class="nav-text">234. 回文链表</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Peter chen</p>
  <div class="site-description" itemprop="description">siyuan Chen personal page</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Peter chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
